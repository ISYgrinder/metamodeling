(*
Summarized possible dependencies, which are not covered with the startup: 

ASC_GlobalProcedures_ExecuteFlowchart
ASC_GlobalProcedures_ExecAttrProf-beeup
ASC_GlobalVariables_FC
ASC_HttpRequestDll



*)

#ASC_GlobalVariables_FC

# Version: 1.0.0
# Date: 2021-08-16

# This file contains global variables with names and IDs of Flowchart concepts.


### Direct Dependencies: None



SETG global_str_fc_outputwin:("Flowchart execution")
SETG global_str_fc_debugwin:("Flowchart execution - debug")


# Concept names
SETG global_str_fc_start:("Start Terminal (FC)")
SETG global_str_fc_operation:("Operation (FC)")
SETG global_str_fc_exoperation:("External Operation (FC)")
SETG global_str_fc_decision:("Decision (FC)")
SETG global_str_fc_switch:("Switch (FC)")
SETG global_str_fc_end:("End Terminal (FC)")
SETG global_str_fc_relnode:("Relation Node")
SETG global_str_fc_subsequent:("Subsequent")
# Attribute names
# Attributes of Start
SETG global_str_fc_execdelay:("Delay (seconds)")
SETG global_str_fc_debugconsole:("Show debug output")
SETG global_str_fc_printtimes:("Print start/end times")
SETG global_str_fc_highlight:("Highlight executed element")
SETG global_str_fc_reqvars:("Required Variables")
SETG global_str_fc_retvars:("Returned Variables")
# Attributes of Operations
SETG global_str_fc_optype:("Type")
SETG global_str_fc_opcode:("Operation code")
SETG global_str_fc_opactive:("Activated")
# Attributes of External Operation
SETG global_str_fc_exoptype:("External type")
SETG global_str_fc_exopinvars:("Passed Variables")
SETG global_str_fc_exopoutvars:("Returned Variables")
SETG global_str_fc_exoprefmodstart:("Start point")
SETG global_str_fc_exopdisablepre:("Disable Pre-processing")
SETG global_str_fc_exopdisablepost:("Disable Post-processing")
SETG global_str_fc_exopasfcall:("AdoScript functionality")
SETG global_str_fc_exophttpcall:("HTTP call")
SETG global_str_fc_exopoliveopcall:("Olive operation call")
SETG global_str_fc_exopsyscall:("System call")
SETG global_str_fc_exopcompcall:("Complex functionality")
SETG global_str_fc_exopcompoutwins:("Output window behaviour")
SETG global_str_fc_exopactive:("Activated")
# Attributes of Decision
SETG global_str_fc_deccode:("Check expression")
SETG global_str_fc_decactive:("Activated")
# Attributes of Switch
SETG global_str_fc_switchcode:("Evaluate expression")
SETG global_str_fc_switchactive:("Activated")
# Attributes of End
SETG global_str_fc_endingtype:("Ending type")
SETG global_str_fc_enddescription:("Description")
# Attributes of Subsequent
SETG global_str_fc_expres:("Expression result")
SETG global_str_fc_compare:("Compare expression")
SETG global_str_fc_gate:("Flowchart condition")
# Attributes Required Variables
SETG global_str_fc_reqvar_name:("Variable name")
SETG global_str_fc_reqvar_type:("Variable type")
SETG global_str_fc_reqvar_def:("Default value")
# Attributes of Passed Variables
SETG global_str_fc_invars_varname:("Variable")
SETG global_str_fc_invars_as:("As")
# Attributes of Returned Variables
SETG global_str_fc_outvars_varname:("Variable")
SETG global_str_fc_outvars_as:("As")

# Enumeration values of exoptype
SETG global_str_fc_exoptype_undef:("Unspecified")
SETG global_str_fc_exoptype_model:("Model")
SETG global_str_fc_exoptype_asf:("AdoScript functionality")
SETG global_str_fc_exoptype_http:("HTTP call")
SETG global_str_fc_exoptype_oliveop:("Olive operation call")
SETG global_str_fc_exoptype_system:("System call")
SETG global_str_fc_exoptype_comp:("Complex functionality")

# Enumeration values of exopcompoutwins
SETG global_str_fc_exopcompoutwins_ignore:("Ignore")
SETG global_str_fc_exopcompoutwins_reuseif:("Reuse (if available)")
SETG global_str_fc_exopcompoutwins_reusemake:("Reuse (make available)")
SETG global_str_fc_exopcompoutwins_reset:("Reset")
SETG global_str_fc_exopcompoutwins_default:("Default")

# Flowchart Start
CC "Core" GET_CLASS_ID classname:(global_str_fc_start)
SETG global_id_fc_start:(classid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_start) attrname:(global_str_fc_execdelay)
SETG global_id_fc_execdelay:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_start) attrname:(global_str_fc_debugconsole)
SETG global_id_fc_debugconsole:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_start) attrname:(global_str_fc_printtimes)
SETG global_id_fc_printtimes:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_start) attrname:(global_str_fc_highlight)
SETG global_id_fc_highlight:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_start) attrname:(global_str_fc_reqvars)
SETG global_id_fc_reqvars:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_start) attrname:(global_str_fc_retvars)
SETG global_id_fc_retvars:(attrid)

# Flowchart Operation
CC "Core" GET_CLASS_ID classname:(global_str_fc_operation)
SETG global_id_fc_operation:(classid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_operation) attrname:(global_str_fc_optype)
SETG global_id_fc_optype:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_operation) attrname:(global_str_fc_opcode)
SETG global_id_fc_opcode:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_operation) attrname:(global_str_fc_opactive)
SETG global_id_fc_opactive:(attrid)

# Flowchart External Operation
CC "Core" GET_CLASS_ID classname:(global_str_fc_exoperation)
SETG global_id_fc_exoperation:(classid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exoptype)
SETG global_id_fc_exoptype:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopinvars)
SETG global_id_fc_exopinvars:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopoutvars)
SETG global_id_fc_exopoutvars:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exoprefmodstart)
SETG global_id_fc_exoprefmodstart:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopdisablepre)
SETG global_id_fc_exopdisablepre:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopdisablepost)
SETG global_id_fc_exopdisablepost:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopasfcall)
SETG global_id_fc_exopasfcall:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exophttpcall)
SETG global_id_fc_exophttpcall:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopoliveopcall)
SETG global_id_fc_exopoliveopcall:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopsyscall)
SETG global_id_fc_exopsyscall:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopcompcall)
SETG global_id_fc_exopcompcall:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopcompoutwins)
SETG global_id_fc_exopcompoutwins:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_exoperation) attrname:(global_str_fc_exopactive)
SETG global_id_fc_exopactive:(attrid)

# Flowchart Decision
CC "Core" GET_CLASS_ID classname:(global_str_fc_decision)
SETG global_id_fc_decision:(classid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_decision) attrname:(global_str_fc_deccode)
SETG global_id_fc_deccode:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_decision) attrname:(global_str_fc_decactive)
SETG global_id_fc_decactive:(attrid)

# Flowchart Switch
CC "Core" GET_CLASS_ID classname:(global_str_fc_switch)
SETG global_id_fc_switch:(classid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_switch) attrname:(global_str_fc_switchcode)
SETG global_id_fc_switchcode:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_switch) attrname:(global_str_fc_switchactive)
SETG global_id_fc_switchactive:(attrid)

# Flowchart End
CC "Core" GET_CLASS_ID classname:(global_str_fc_end)
SETG global_id_fc_end:(classid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_end) attrname:(global_str_fc_endingtype)
SETG global_id_fc_endingtype:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_end) attrname:(global_str_fc_enddescription)
SETG global_id_fc_enddescription:(attrid)

# Flowchart Relation Node
CC "Core" GET_CLASS_ID classname:(global_str_fc_relnode)
SETG global_id_fc_relnode:(classid)

# Flowchart Subsequent
CC "Core" GET_CLASS_ID relation classname:(global_str_fc_subsequent)
SETG global_id_fc_subsequent:(classid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_subsequent) attrname:(global_str_fc_expres)
SETG global_id_fc_expres:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_subsequent) attrname:(global_str_fc_compare)
SETG global_id_fc_compare:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_fc_subsequent) attrname:(global_str_fc_gate)
SETG global_id_fc_gate:(attrid)



#ASC_HttpRequestDll

# Version: 1.4.0
# Date: 2021-08-16

#------------------------------------------------------------------------------
# A collection of procedures which help using the HttpRequestFunctions.dll.
# While the same things could be achieved by a direct AdoScript "CALL", the
# here provided procedures are supposed to make life simpler.
# The provided procedures differ in three aspects:
# * should Authentication be used?
# * should the provided request body be decoded before sending?
# * should the response be encoded before retrieving it (e.g. because it
#   contains NUL bytes \0)?
#
# Some aspects are also controlled through global variables. Details for these
# are described further below where their default values are also initialized.
#
# The procedures only work properly when the HttpRequestFunctions.dll and
# libcurl.dll are in the same folder. For HTTPS requests curl-ca-bundle.crt
# is also needed in the same folder.
#
# The DLL and the here provided procedures aren't too fancy, and try mostly to
# remain as flexible as possible. As such there aren't different procedures for
# the different HTTP methods and the procedures don't provide the luxury of
# automatically processing "HTTP parameters" like other web-frameworks do. So
# parameters of a POST call have to be put in manually as part of the body,
# e.g. in case of transmitting 'application/x-www-form-urlencoded' content the
# body of a POST form call is the parameters using the URL Query encoding.
# Some functions to support escaping text using URL encoding or maps into URL
# Query encoding are provided.
#
# If you quickly want to jump through the different procedures available then
# simply search for "PROCEDURE global".
#
# A small hint from the author: AdoScript maps are very similar to valid JSON.
# An AdoScript map can be "transformed to a JSON string" using the STR function
# and a string containing JSON can be "transformed to an AdoScript map" by
# using AdoScript's eval function, like:
#    SETL mymap:(eval(thejsonstring))
# or using the EXECUTE command, like:
#    EXECUTE ("SETL mymap:(" + thejsonstring + ")") scope:same
# As long as the keys are always of type string and the values are either
# strings, numbers or other maps the concepts of AdoScript maps and JSON
# overlap.
# However, it is necessary to consider the differences between the two formats.
# Besides ADOxx using ASCII/ANSI characters there are also other differences:
# - AdoScript maps allow any data-type to be a key, while JSON requires keys to
#   be strings.
# - AdoScript handles arrays using { and }, while JSON uses [ ]. Therefore
#   arrays between the two are not compatible.
# - AdoScript doesn't know true, false and null. For boolean AdoScript uses
#   the numbers 0 and 1, but does not automatically transform true to 1 and
#   false to 0 (or vice versa). Instead, values that can't be handled become
#   of type "undefined" in AdoSCript. The typical null value can be compared to
#   AdoScript's "undefined" type, however the automatic transformation works
#   only in one direction: If the JSON contains null, it will be a value of
#   type "undefined" in the AdoScript map.
# So, it is in many cases easy to send JSON requests by simply creating an
# AdoScript map and transforming it to a string using STR. Using AdoScript maps
# to process JSON responses can also be used in many cases.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# GLOBAL VARIABLES
# NOTE: These are the default values used for the global variables. Instead of
# changing these it is recommended to set their values through SETG after this
# file has been loaded.
#------------------------------------------------------------------------------
# Specifies the location of the DLL.
CC "Application" GET_PATH
SETG global_str_dll_dllfolder:(path + "\\httpreq")
SETG global_str_dll_httprequest:("HttpRequestFunctions.dll")
# Specifies whether verification of certificats should be skipped.
# Set to 1 to skip verification.
SETG global_val_skipVerification:(0)


#------------------------------------------------------------------------------
# If the procedures provided here are to restrictive, then you can directly
# CALL the required DLL.
# Example:
IF (0) {
  # This sends an HTTP request to "http://localhost:8080/EchoService/e/", which
  # contains some request headers and a simple request body using the GET HTTP
  # method. The details are then presented to the user.

  # This map is used to represent the headers of the request
  SETL tempmap:({"Content-Type": "text/plain"})
  # Perform the call actual call.
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CALL dll:(global_str_dll_httprequest) function:"long sendEncodedRequestEncodeResponse(char* url, char* method, char* requestHeaders, char* requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char** responseHeaders, char** responseBody)"
    url:("http://localhost:8080/EchoService/e/")
    method:("GET")
    requestHeaders:(STR tempmap)
    requestBody:("Somebody")
    requestBodyEncoding:(0)
    responseBodyEncoding:(0)
    optionFlags:(0)
    result:responseCode
  CC "AdoScript" SET_CWD path:(str_oldCwd)
  # Create a string that contains all of the response details and show it.
  SETL responseDetailsString:(STR responseCode + "\n\n" + responseHeaders + "\n\n" + responseBody)
  CC "AdoScript" VIEWBOX text:(responseDetailsString)
  # Transform the response headers into a map and show that map.
  SETL tempmap:(eval(responseHeaders))
  CC "AdoScript" VIEWBOX text:(type(tempmap) + "\n\n" + STR tempmap)

  # Using the provided procedures, the code would instead look like this:
  SETL tempmap:({"Content-Type": "text/plain"})
  HTTP_SEND_REQUEST ("http://localhost:8080/EchoService/e/") str_method:("GET") map_reqheaders:(tempmap) str_reqbody:("Somebody") val_respcode:respstat map_respheaders:respheaders str_respbody:respbody
  SETL responseDetailsString:(STR respstat + "\n\n" + STR respheaders + "\n\n" + respbody)
  CC "AdoScript" VIEWBOX text:(responseDetailsString)
  CC "AdoScript" VIEWBOX text:(type(respheaders) + "\n" + STR respheaders)
}
#------------------------------------------------------------------------------




#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_REQUEST string:str_url
      str_method:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Performs a normal HTTP request to the specified URL. The response is stored
# in the corresponding parameters.
# Important note: The call to the DLL assumes null-terminated C strings. As
# such there can be problems when the response contains a NUL byte (\0) as part
# of the content (e.g. like PNG images). If you anticipate this to be the case
# please use one of the other procedures (HTTP_SEND_REQUEST_BASE or
# HTTP_SEND_REQUEST_BYTES).
# str_url - The main parameter should specify the URL where the request should
#     be sent. In case of GET requests the "HTTP parameters" should be part of
#     the URL query.
# str_method - Which HTTP method should be used. Common are GET, PUT, POST,
#     DELETE, but also HEAD, OPTIONS, TRACE and others are possible. Just
#     remember that the standardized HTTP methods should use upper case.
# map_reqheaders - A map containing the headers to be sent with this request.
#     Some seem to always be present automatically when needed (e.g. "Accept",
#     "Content-Length"), but others like "Content-Type" or "Authorization"
#     should be specified through this map. In any case both the keys and the
#     values of the map should be strings, or if you don't want to specify any
#     additional headers just use (map()) for this parameter.
# str_reqbody - The body that should be sent with the request. In case of "PUT"
#     and "POST" requests it should contain the desired parameters, which can
#     be simple in some cases (e.g. a string containing valid JSON code), or
#     more complicated in others (e.g. an application/x-www-form-urlencoded 
#     request has to URL-encode the parameters). It is up to the procedure
#     caller to produce the proper body content.
# val_respcode - a reference that will contain the HTTP status code answered
#     by the server or possibly 0 if something went wrong before the request
#     could be sent / the response be received.
# map_respheaders - a reference that will contain an AdoScript map with the
#     response headers. Both the keys and the values will be of type string.
# str_respbody - a reference that will contain the response of the server as 
#     a string or more details about an error if something has gone wrong.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendRequest(char *url, char *method, char *requestHeaders, char *requestBody, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_AUTH_REQUEST string:str_url
      str_method:string
      str_username:string
      str_password:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Performs an HTTP request with basic authentication to the specified URL. The
# response is stored in the corresponding parameters.
# Important note: The call to the DLL assumes null-terminated C strings. As
# such there can be problems when the response contains a NUL byte (\0) as part
# of the content (e.g. like PNG images). If you anticipate this to be the case
# please use one of the other procedures (HTTP_SEND_AUTH_REQUEST_BASE or
# HTTP_SEND_AUTH_REQUEST_BYTES).
# str_url - The main parameter should specify the URL where the request should
#     be sent. In case of GET requests the "HTTP parameters" should be part of
#     the URL query.
# str_method - Which HTTP method should be used. Common are GET, PUT, POST,
#     DELETE, but also HEAD, OPTIONS, TRACE and others are possible. Just
#     remember that the standardized HTTP methods should use upper case.
# str_username - The user name to use with basic authentication.
# str_password - The password to use with basic authentication.
# map_reqheaders - A map containing the headers to be sent with this request.
#     Some seem to always be present automatically when needed (e.g. "Accept",
#     "Content-Length"), but others like "Content-Type" or "Authorization"
#     should be specified through this map. In any case both the keys and the
#     values of the map should be strings, or if you don't want to specify any
#     additional headers just use (map()) for this parameter.
# str_reqbody - The body that should be sent with the request. In case of "PUT"
#     and "POST" requests it should contain the desired parameters, which can
#     be simple in some cases (e.g. a string containing valid JSON code), or
#     more complicated in others (e.g. a application/x-www-form-urlencoded 
#     request has to url-encode the parameters). It is up to the procedure
#     caller to produce the proper body content.
# val_respcode - a reference that will contain the HTTP status code answered
#     by the server or possibly 0 if something went wrong before the request
#     could be sent / the response be received.
# map_respheaders - a reference that will contain an AdoScript map with the
#     response headers. Both the keys and the values will be of type string.
# str_respbody - a reference that will contain the response of the server as 
#     a string or more details about an error if something has gone wrong.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendAuthRequest(char *url, char *username, char *password, char *method, char *requestHeaders, char *requestBody, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) username:(str_username) password:(str_password) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_REQUEST_BASE string:str_url
      str_method:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Performs a normal HTTP request to the specified URL. The response is stored
# in the corresponding parameters. Unlike HTTP_SEND_REQUEST a successful
# response will be encoded as base64. This can be important when the content of
# the response can contain NUL bytes (\0).
# str_url - The main parameter should specify the URL where the request should
#     be sent. In case of GET requests the "HTTP parameters" should be part of
#     the URL query.
# str_method - Which HTTP method should be used. Common are GET, PUT, POST,
#     DELETE, but also HEAD, OPTIONS, TRACE and others are possible. Just
#     remember that the standardized HTTP methods should use upper case.
# map_reqheaders - A map containing the headers to be sent with this request.
#     Some seem to always be present automatically when needed (e.g. "Accept",
#     "Content-Length"), but others like "Content-Type" or "Authorization"
#     should be specified through this map. In any case both the keys and the
#     values of the map should be strings, or if you don't want to specify any
#     additional headers just use (map()) for this parameter.
# str_reqbody - The body that should be sent with the request. In case of "PUT"
#     and "POST" requests it should contain the desired parameters, which can
#     be simple in some cases (e.g. a string containing valid JSON code), or
#     more complicated in others (e.g. a application/x-www-form-urlencoded 
#     request has to url-encode the parameters). It is up to the procedure
#     caller to produce the proper body content.
# val_respcode - a reference that will contain the HTTP status code answered
#     by the server or possibly 0 if something went wrong before the request
#     could be sent / the response be received.
# map_respheaders - a reference that will contain an AdoScript map with the
#     response headers. Both the keys and the values will be of type string.
# str_respbody - a reference that will contain the response of the server or
#     the error message as a base64 encoded string.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendEncodedRequestEncodeResponse(char *url, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(0) responseBodyEncoding:(1) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_AUTH_REQUEST_BASE string:str_url
      str_method:string
      str_username:string
      str_password:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Performs an HTTP request with basic authentication to the specified URL. The
# response is stored in the corresponding parameters. Unlike
# HTTP_SEND_AUTH_REQUEST a successful response will be encoded as base64. This
# can be important when the content of the response can contain NUL bytes (\0).
# str_url - The main parameter should specify the URL where the request should
#     be sent. In case of GET requests the "HTTP parameters" should be part of
#     the URL query.
# str_method - Which HTTP method should be used. Common are GET, PUT, POST,
#     DELETE, but also HEAD, OPTIONS, TRACE and others are possible. Just
#     remember that the standardized HTTP methods should use upper case.
# str_username - The user name to use with basic authentication.
# str_password - The password to use with basic authentication.
# map_reqheaders - A map containing the headers to be sent with this request.
#     Some seem to always be present automatically when needed (e.g. "Accept",
#     "Content-Length"), but others like "Content-Type" or "Authorization"
#     should be specified through this map. In any case both the keys and the
#     values of the map should be strings, or if you don't want to specify any
#     additional headers just use (map()) for this parameter.
# str_reqbody - The body that should be sent with the request. In case of "PUT"
#     and "POST" requests it should contain the desired parameters, which can
#     be simple in some cases (e.g. a string containing valid JSON code), or
#     more complicated in others (e.g. a application/x-www-form-urlencoded 
#     request has to url-encode the parameters). It is up to the procedure
#     caller to produce the proper body content.
# val_respcode - a reference that will contain the HTTP status code answered
#     by the server or possibly 0 if something went wrong before the request
#     could be sent / the response be received.
# map_respheaders - a reference that will contain an AdoScript map with the
#     response headers. Both the keys and the values will be of type string.
# str_respbody - a reference that will contain the response of the server or
#     the error message as a base64 encoded string.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendAuthEncodedRequestEncodeResponse(char *url, char *username, char *password, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) username:(str_username) password:(str_password) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(0) responseBodyEncoding:(1) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_REQUEST_BYTES string:str_url
      str_method:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      arr_respbody:reference
# Performs a normal HTTP request to the specified URL. The response is stored
# in the corresponding parameters. Unlike HTTP_SEND_REQUEST a successful
# response will be an array of bytes. The bytes are in the decimal number
# system. This can be important when the content of the response can contain
# NUL bytes (\0).
# str_url - The main parameter should specify the URL where the request should
#     be sent. In case of GET requests the "HTTP parameters" should be part of
#     the URL query.
# str_method - Which HTTP method should be used. Common are GET, PUT, POST,
#     DELETE, but also HEAD, OPTIONS, TRACE and others are possible. Just
#     remember that the standardized HTTP methods should use upper case.
# map_reqheaders - A map containing the headers to be sent with this request.
#     Some seem to always be present automatically when needed (e.g. "Accept",
#     "Content-Length"), but others like "Content-Type" or "Authorization"
#     should be specified through this map. In any case both the keys and the
#     values of the map should be strings, or if you don't want to specify any
#     additional headers just use (map()) for this parameter.
# str_reqbody - The body that should be sent with the request. In case of "PUT"
#     and "POST" requests it should contain the desired parameters, which can
#     be simple in some cases (e.g. a string containing valid JSON code), or
#     more complicated in others (e.g. a application/x-www-form-urlencoded 
#     request has to url-encode the parameters). It is up to the procedure
#     caller to produce the proper body content.
# val_respcode - a reference that will contain the HTTP status code answered
#     by the server or possibly 0 if something went wrong before the request
#     could be sent / the response be received.
# map_respheaders - a reference that will contain an AdoScript map with the
#     response headers. Both the keys and the values will be of type string.
# arr_respbody - a reference that will contain the response of the server or
#     the error message as an array of bytes in the decimal number system.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendEncodedRequestEncodeResponse(char *url, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(0) responseBodyEncoding:(3) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  EXECUTE ("SETL arr_respbody:({" + str_responseBody + "})") scope:same
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_AUTH_REQUEST_BYTES string:str_url
      str_method:string
      str_username:string
      str_password:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      arr_respbody:reference
# Performs an HTTP request with basic authentication to the specified URL. The
# response is stored in the corresponding parameters. Unlike 
# HTTP_SEND_AUTH_REQUEST a successful response will be an array of bytes. The
# bytes are in the decimal number system. This can be important when the
# content of the response can contain NUL bytes (\0).
# str_url - The main parameter should specify the URL where the request should
#     be sent. In case of GET requests the "HTTP parameters" should be part of
#     the URL query.
# str_method - Which HTTP method should be used. Common are GET, PUT, POST,
#     DELETE, but also HEAD, OPTIONS, TRACE and others are possible. Just
#     remember that the standardized HTTP methods should use upper case.
# str_username - The user name to use with basic authentication.
# str_password - The password to use with basic authentication.
# map_reqheaders - A map containing the headers to be sent with this request.
#     Some seem to always be present automatically when needed (e.g. "Accept",
#     "Content-Length"), but others like "Content-Type" or "Authorization"
#     should be specified through this map. In any case both the keys and the
#     values of the map should be strings, or if you don't want to specify any
#     additional headers just use (map()) for this parameter.
# str_reqbody - The body that should be sent with the request. In case of "PUT"
#     and "POST" requests it should contain the desired parameters, which can
#     be simple in some cases (e.g. a string containing valid JSON code), or
#     more complicated in others (e.g. a application/x-www-form-urlencoded 
#     request has to url-encode the parameters). It is up to the procedure
#     caller to produce the proper body content.
# val_respcode - a reference that will contain the HTTP status code answered
#     by the server or possibly 0 if something went wrong before the request
#     could be sent / the response be received.
# map_respheaders - a reference that will contain an AdoScript map with the
#     response headers. Both the keys and the values will be of type string.
# arr_respbody - a reference that will contain the response of the server or
#     the error message as an array of bytes in the decimal number system.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendAuthEncodedRequestEncodeResponse(char *url, char *username, char *password, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) username:(str_username) password:(str_password) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(0) responseBodyEncoding:(1) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  EXECUTE ("SETL arr_respbody:({" + str_responseBody + "})") scope:same
}


###############################################################################
# The detailed documentation has been mostly skipped for some of the following
# procedures, since they are mostly the same.
# They are a special version of the previous procedures which will decode the
# str_reqbody using base64 before sending it to the specified URL. If you want
# to send the data still base64 encoded then use the previous procedures.
# Otherwise they behave the same.
###############################################################################


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_REQUEST_INBASE string:str_url
      str_method:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Same as previous procedure HTTP_SEND_REQUEST, only that it expects the
# request body (str_reqbody) to be base64 encoded and decodes it to a plain
# string before sending it to the server.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendEncodedRequestEncodeResponse(char *url, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(1) responseBodyEncoding:(0) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_AUTH_REQUEST_INBASE string:str_url
      str_method:string
      str_username:string
      str_password:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Same as previous procedure HTTP_SEND_AUTH_REQUEST, only that it expects the
# request body (str_reqbody) to be base64 encoded and decodes it to a plain
# string before sending it to the server.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendAuthEncodedRequestEncodeResponse(char *url, char *username, char *password, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) username:(str_username) password:(str_password) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(1) responseBodyEncoding:(0) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_REQUEST_BASE_INBASE string:str_url
      str_method:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Same as previous procedure HTTP_SEND_REQUEST_BASE, only that it expects the
# request body (str_reqbody) to be base64 encoded and decodes it to a plain
# string before sending it to the server.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendEncodedRequestEncodeResponse(char *url, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(1) responseBodyEncoding:(1) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_AUTH_REQUEST_BASE_INBASE string:str_url
      str_method:string
      str_username:string
      str_password:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      str_respbody:reference
# Same as previous procedure HTTP_AUTH_SEND_REQUEST_BASE, only that it expects
# the request body (str_reqbody) to be base64 encoded and decodes it to a plain
# string before sending it to the server.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendAuthEncodedRequestEncodeResponse(char *url, char *username, char *password, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) username:(str_username) password:(str_password) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(1) responseBodyEncoding:(1) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  SETL str_respbody:(str_responseBody)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_REQUEST_BYTES_INBASE string:str_url
      str_method:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      arr_respbody:reference
# Same as previous procedure HTTP_SEND_REQUEST_BYTES, only that it expects the
# request body (str_reqbody) to be base64 encoded and decodes it to a plain
# string before sending it to the server.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendEncodedRequestEncodeResponse(char *url, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(1) responseBodyEncoding:(3) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  EXECUTE ("SETL arr_respbody:({" + str_responseBody + "})") scope:same
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_SEND_AUTH_REQUEST_BYTES_INBASE string:str_url
      str_method:string
      str_username:string
      str_password:string
      map_reqheaders:map
      str_reqbody:string
      val_respcode:reference
      map_respheaders:reference
      arr_respbody:reference
# Same as previous procedure HTTP_SEND_AUTH_REQUEST_BYTES, only that it expects
# the request body (str_reqbody) to be base64 encoded and decodes it to a plain
# string before sending it to the server.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }
  
  CALL dll:(global_str_dll_httprequest) function:"long sendAuthEncodedRequestEncodeResponse(char *url, char *username, char *password, char *method, char *requestHeaders, char *requestBody, long requestBodyEncoding, long responseBodyEncoding, long optionFlags, char **str_responseHeaders, char **str_responseBody)" url:(str_url) username:(str_username) password:(str_password) method:(str_method) requestHeaders:(STR map_reqheaders) requestBody:(str_reqbody) requestBodyEncoding:(1) responseBodyEncoding:(3) optionFlags:(global_val_skipVerification) result:val_respcode
  CC "AdoScript" SET_CWD path:(str_oldCwd)

  IF (val_respcode > 0) {
    EXECUTE ("SETL map_respheaders:(" + str_responseHeaders + ")") scope:same
    IF (type(map_respheaders) = "array") {
      SETL map_respheaders:(map())
    }
  } ELSE {
    SETL map_respheaders:(map())
  }
  EXECUTE ("SETL arr_respbody:({" + str_responseBody + "})") scope:same
  CC "AdoScript" SET_CWD path:(str_oldCwd)
}


###############################################################################
# The following procedures are to help with some of the tasks facing when
# calling a service via HTTP.
###############################################################################


#------------------------------------------------------------------------------
PROCEDURE global HTTP_URL_ENCODE string:str_content
      str_allowedset:string
      str_encoded:reference
# Takes a text and uses URL encoding to escape any unsafe/not-allowed
# characters. Characters which are not allowed are replaced with one or more
# %xx where xx is an 8-bit hexadecimal number. Useful for sending POST requests
# with content-type 'application/x-www-form-urlencoded'.
# str_content - The content that should be encoded using URL encoding style.
#     Consider providing the main parameter with the toutf8(...) function of
#     ADOxx, since most web things work with UTF-8 while ADOxx seems to use
#     Windows-1252. Using toutf8(...) on the main parameter will for example
#     encode the small a-umlaut as %C3%A4 (as should be for UTF-8) instead of
#     just %E4. If you're only using the ASCII characters then toutf8(...)
#     shouldn't be necessary.
# str_allowedset - Should be "JS", "Inter", "Lax" or "VeryLax". If an unknown
#     value is specified then "JS" will be used by default. This parameter
#     specifies which of the four available sets containing the "allowed
#     characters" to use. Anything that isn't an allowed character will be
#     encoded.
#     "JS" allows the same characters as the on the Java Script
#     encodeURIComponent() function (from Firefox / Chrome). Probably the
#     safest bet in most cases.
#     "Inter" is a list of characters based from several sources, including the
#     URI specification.
#     "Lax" allows everything except non-ASCII characters, ASCII control
#     characters (0x00 to 0x20 and 0x7F), # (0x23), % (0x25), & (0x26),
#     + (0x2B), = (0x3D) and ? (0x3F)
#     "VeryLax" allows everything except non-ASCII characters, ASCII control
#     characters (0x00 to 0x20 and 0x7F), % (0x25), & (0x26) and = (0x3D)
# str_encoded - a reference that will contain the encoded content. Will only
#     consist of the characters from the allowed set and % used to encode other
#     characters.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }

  SETL val_characterSet:(0)
  IF (str_allowedset = "Inter") {
    SETL val_characterSet:(1)
  } ELSIF (str_allowedset = "Lax") {
    SETL val_characterSet:(2)
  } ELSIF (str_allowedset = "VeryLax") {
    SETL val_characterSet:(3)
  }
  CALL dll:(global_str_dll_httprequest) function:"char* escapeUrlStyle(char *text, long characterSet)" text:(str_content) characterSet:(val_characterSet) result:str_encoded
  CC "AdoScript" SET_CWD path:(str_oldCwd)
}


#------------------------------------------------------------------------------
PROCEDURE global HTTP_URL_ENCODE_QUERY map:map_content
      str_allowedset:string
      str_encoded:reference
# Takes a map containing key-value pairs and uses URL encoding to escape any
# unsafe/not-allowed characters and builds a string which follows the structure
# of the query-portion of a URL. This is used for example by data which is sent
# as 'application/x-www-form-urlencoded' Characters which are not allowed are
# replaced with one or more %xx where xx is an 8-bit hexadecimal number.
# map_content - a map containing keys and their values which should be
#     transformed into the structure of the URL-query-portion. When creating
#     the map consider using the toutf8(...) function of ADOxx for the keys
#     and values (especially the values), since most web things work with
#     UTF-8 while ADOxx seems to use Windows-1252. Using toutf8(...) on the
#     main parameter will for example encode the small a-umlaut as %C3%A4 (as
#     should be for UTF-8) instead of just %E4. If you're only using the ASCII
#     characters then toutf8(...) shouldn't be necessary.
#     Both the keys and the values of the map have to be of type string.
# str_allowedset - Should be "JS", "Inter", "Lax" or "VeryLax". If an unknown
#     value is specified then "JS" will be used by default. This parameter
#     specifies which of the four available sets containing the "allowed
#     characters" to use. Anything that isn't an allowed character will be
#     encoded.
#     "JS" allows the same characters as the on the Java Script
#     encodeURIComponent() function (from Firefox / Chrome). Probably the
#     safest bet in most cases.
#     "Inter" is a list of characters based from several sources, including the
#     URI specification.
#     "Lax" allows everything except non-ASCII characters, ASCII control
#     characters (0x00 to 0x20 and 0x7F), # (0x23), % (0x25), & (0x26),
#     + (0x2B), = (0x3D) and ? (0x3F)
#     "VeryLax" allows everything except non-ASCII characters, ASCII control
#     characters (0x00 to 0x20 and 0x7F), % (0x25), & (0x26) and = (0x3D)
# str_encoded - a reference that will contain the encoded content. Will only
#     consist of the characters from the allowed set, % used to encode other
#     characters and & and = which are used by
#     'application/x-www-form-urlencoded'.
#------------------------------------------------------------------------------
{
  CC "AdoScript" GET_CWD
  SETL str_oldCwd:(cwd)
  CC "AdoScript" SET_CWD path:(global_str_dll_dllfolder)
  CC "AdoScript" FILE_EXISTS file:(global_str_dll_httprequest)
  IF (NOT exists) {
    CC "AdoScript" ERRORBOX ("The necessary DLL could not be found at\n" + global_str_dll_httprequest) title:("File not found")
    EXIT
  }

  SETL val_characterSet:(0)
  IF (str_allowedset = "Inter") {
    SETL val_characterSet:(1)
  } ELSIF (str_allowedset = "Lax") {
    SETL val_characterSet:(2)
  } ELSIF (str_allowedset = "VeryLax") {
    SETL val_characterSet:(3)
  }
  CALL dll:(global_str_dll_httprequest) function:"char* toQueryString(char *jsonAsChars, long characterSet)" jsonAsChars:(STR map_content) characterSet:(val_characterSet) result:str_encoded
  CC "AdoScript" SET_CWD path:(str_oldCwd)
}


# ASC_GlobalProcedures_ExecAttrProf-beeup

# Version: 1.1.0-beeup
# Date: 2022-01-18

# This file contains global variables, functions and procedures to execute
# special attribute profiles representing functionalities similar to add-ons.

##### BEE-UP SPECIFIC START
# This version of the module is adapted for Bee-Up to include attribute
# profiles for the execution of Flowcharts. Easiest way to find the changes is
# to search for "BEE-UP SPECIFIC".
##### BEE-UP SPECIFIC END


### Direct Dependencies:
# * ASC_GlobalFunctions_Conversion.asc
# * ASC_GlobalFunctions_JSON.asc
# * ASC_GlobalFunctions_MapSupport.asc
# * ASC_HttpRequestDll.asc
# * ASC_GlobalProcedures_ExecuteFlowchart.asc - BEE-UP SPECIFIC


# In general the procedures expect an attribute profile object which describes
# how the functionality should be executed. Relevant procedures to use:
# * EXECAP_HTTP_CALL (VAL attrprofids) val_httpcode:dummy map_respheaders:dummy str_respbody:dummy
# * EXECAP_SYSTEM_CALL (VAL attrprofids)
# * EXECAP_ADOSCRIPT_CALL (VAL attrprofids)
# * EXECAP_OLIVE_SERVICE_CALL (VAL attrprofids)
# * EXECAP_COMPLEX_CALL (VAL attrprofids) -> Flowcharts # BEE-UP SPECIFIC


# The procedures use the ecode to inform about errors that happen.
# However ecode from CC seems to be "kind of local" unless we make it global.
SETG ecode:(0)
# Same for errtext
SETG errtext:("")


# Concept names
SETG global_str_execap_genericasf:("AdoScript Functionality (Code)")
SETG global_str_execap_generichttp:("HTTP-called Functionality (Code)")
SETG global_str_execap_genericsys:("System-called Functionality (Code)")
SETG global_str_execap_genericolive:("Call Operation (Olive MSC, Code)")
# Attribute names - AdoScript Functionality
SETG global_str_execap_asf_filelinks:("File links")
SETG global_str_execap_asf_code:("AdoScript code")
SETG global_str_execap_genasf_preproc:("Pre-processing")
SETG global_str_execap_genasf_postproc:("Post-processing")
# Attribute names - HTTP-called Functionality
SETG global_str_execap_http_endpoint:("Endpoint")
SETG global_str_execap_http_method:("Method")
SETG global_str_execap_http_auth:("Authentication")
SETG global_str_execap_http_uname:("Username")
SETG global_str_execap_http_passwd:("Password")
SETG global_str_execap_genhttp_preproc:("Pre-processing")
SETG global_str_execap_genhttp_postproc:("Post-processing")
# Attribute names - System-called Functionality
SETG global_str_execap_sys_cmd:("Command")
SETG global_str_execap_sys_args:("Arguments")
SETG global_str_execap_sys_showcmd:("Show console")
SETG global_str_execap_gensys_preproc:("Pre-processing")
SETG global_str_execap_gensys_postproc:("Post-processing")
# Attribute names - Call Operation (Olive)
SETG global_str_execap_olive_endpoint:("Endpoint")
SETG global_str_execap_olive_microserviceid:("Microservice ID")
SETG global_str_execap_olive_microservicename:("Microservice name")
SETG global_str_execap_olive_operationid:("Operation ID")
SETG global_str_execap_olive_simpleinput:("Use simple input map")
SETG global_str_execap_olive_inputparameters:("Input parameters")
SETG global_str_execap_olive_preproc:("Pre-processing")
SETG global_str_execap_olive_postproc:("Post-processing")
# Attribute names - Arguments
SETG global_str_execap_argsprefconst:("Prefix / Constant")
SETG global_str_execap_argsvarval:("Variable value")
# Attribute names - File links
SETG global_str_execap_flid:("ID")
SETG global_str_execap_flpath:("File")
# Attribute names - Input parameters
SETG global_str_execap_inname:("Input name")
SETG global_str_execap_indefault:("Default value")

# Constant values
SETG global_str_execap_sys_cmd_synchcmd:("Synchronous CMD")
SETG global_str_execap_sys_cmd_asynchcmd:("Asynchronous CMD")
SETG global_str_execap_sys_cmd_app:("Application")

# Concept IDs
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericasf)
SETG global_id_execap_genericasf:(apclassid)
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_generichttp)
SETG global_id_execap_generichttp:(apclassid)
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericsys)
SETG global_id_execap_genericsys:(apclassid)
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericolive)
SETG global_id_execap_genericolive:(apclassid)

# Record IDs
CC "Core" GET_ATTR_ID classid:(global_id_execap_genericasf) attrname:(global_str_execap_asf_filelinks)
SETG global_id_execap_asf_filelinks:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_execap_genericsys) attrname:(global_str_execap_sys_args)
SETG global_id_execap_sys_args:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_execap_genericolive) attrname:(global_str_execap_olive_inputparameters)
SETG global_id_execap_olive_inputparameters:(attrid)


##### BEE-UP SPECIFIC START
# Concept names
SETG global_str_execap_genericcomp:("Complex Functionality (Code)")
# Attribute names - Complex Functionality
SETG global_str_execap_comp_refstart:("Described through")
SETG global_str_execap_comp_reqvars:("Required variables")
SETG global_str_execap_comp_retvars:("Returned variables")
SETG global_str_execap_gencomp_preproc:("Pre-processing")
SETG global_str_execap_gencomp_postproc:("Post-processing")
# Concept IDs
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericcomp)
SETG global_id_execap_genericcomp:(apclassid)
##### BEE-UP SPECIFIC END



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_EXECUTE_ATTRPROF_GUI
# This procedure allows the user to select an Attribute Profile describing a
# functionality and execute it.
#------------------------------------------------------------------------------
{
  # Select which service call to execute
  # BEE-UP SPECIFIC adds to the filter.
  CC "CoreUI" ATTRPROF_SELECT_BOX with-mgmt-functions filter:(STR global_id_execap_generichttp + " " + STR global_id_execap_genericsys + " " + STR global_id_execap_genericcomp + " " + STR global_id_execap_genericasf + " " + STR global_id_execap_genericolive) title:("Execute external functionality") boxtext:("Select which external functionality should be executed.") oktext:("Execute")
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX ("Some error occurred while selecting the functionality:\n" + errtext)
    EXIT
  } ELSIF (endbutton <> "ok") {
    EXIT
  }

  EXECAP_EXECUTE_ATTRPROF (VAL attrprofids)

  # If something went wrong then show the user the error.
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX ("Some error occurred while trying to call the external functionality:\n" + errtext)
    EXIT
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_EXECUTE_ATTRPROF integer:id_functionobj
# This procedure allows the user to select an Attribute Profile describing a
# functionality and execute it.
#------------------------------------------------------------------------------
{
  # Check which procedure has to be called based on the type
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  SETL id_selcid:(apclassid)
  IF (id_selcid = global_id_execap_genericasf) {
    EXECAP_ADOSCRIPT_CALL (id_functionobj)
  } ELSIF (id_selcid = global_id_execap_generichttp) {
    EXECAP_HTTP_CALL (id_functionobj) val_httpcode:dummy map_respheaders:dummy str_respbody:dummy
  } ELSIF (id_selcid = global_id_execap_genericsys) {
    EXECAP_SYSTEM_CALL (id_functionobj)
  } ELSIF (id_selcid = global_id_execap_genericolive) {
    EXECAP_OLIVE_SERVICE_CALL (id_functionobj)
  }
  ##### BEE-UP SPECIFIC START
  ELSIF (id_selcid = global_id_execap_genericcomp) {
    EXECAP_COMPLEX_CALL (id_functionobj)
  }
  ##### BEE-UP SPECIFIC END
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_ADOSCRIPT_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer map_asf_filelinks:map map_asf_inputvars:map str_asf_inputvarskeys:string map_asf_outputvars:reference
# This procedure allows to execute an External Functionality described through
# a "AdoScript Functionality" Attribute Profile and provides the result.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericasf) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericasf)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genasf_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genasf_postproc)
    SETL str_postcallcode:(val)
  }

  # Load in the input
  # If no keys have been specifically provided, then we try to read them out of the map, which can cause problems (e.g. maps in maps)!
  IF (str_asf_inputvarskeys = "") { SETL str_asf_inputvarskeys:(mapKeysList(map_asf_inputvars)) }
  FOR str_asf_key in:(str_asf_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_asf_inputvars[str_asf_key]) = "string") {
      EXECUTE ("SETL " + str_asf_key + ":(\"" + map_asf_inputvars[str_asf_key] + "\")") scope:same
    } ELSIF (type(map_asf_inputvars[str_asf_key]) <> "undefined") {
      EXECUTE ("SETL " + str_asf_key + ":(" + STR map_asf_inputvars[str_asf_key] + ")") scope:same
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Load the linked files into the map unless they're already in there
  # Since we're not the ones doing anything with those files we also just provide their path as is.
  # This works because GET_ALL_REC_ATTR_ROW_IDS seems to return the rows in their correct order.
  CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_functionobj) attrid:(global_id_execap_asf_filelinks)
  FOR str_rowid in:(rowids) {
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_flid) as-string
    SETL str_fileid:(val)
    IF (type(map_asf_filelinks[str_fileid]) = "undefined") {
      CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_flpath) as-string
      SETL str_filepath:(eval(copy(val, search(val, "param:", 0)+6, -1)))
      SETL map_asf_filelinks[str_fileid]:(str_filepath)
    }
  }

  # Execute the specified code
  SETL str_adoscriptcode:("")
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_asf_code)
  SETL str_adoscriptcode:(val)
  IF (str_adoscriptcode <> "") {
    EXECUTE (str_adoscriptcode) scope:same
  }

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }

  # Load the output into the variable, but only if it's a map
  IF (type(map_asf_outputvars) = "map") {
    SETL str_asf_keys:(mapKeysList(map_asf_outputvars))
    FOR str_asf_key in:(str_asf_keys) sep:("~") {
      # We put the values into the output map. Easiest way to do that is using eval.
      SETL map_asf_outputvars[str_asf_key]:(eval(map_asf_outputvars[str_asf_key]))
    }
  } ELSE { # If it's not a map (whyever) then we set it to an empty map
    SETL map_asf_outputvars:(map())
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_ADOSCRIPT_CALL integer:id_functionobj
# This procedure allows to execute an External Functionality described through
# an "AdoScript Functionality" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_ADOSCRIPT_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL temp_emptymap:(map())
  EXECAP_ADOSCRIPT_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) map_asf_filelinks:(map()) map_asf_inputvars:(map()) str_asf_inputvarskeys:("") map_asf_outputvars:temp_emptymap
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_HTTP_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer str_endpoint:string str_method:string str_auth:string str_username:string str_password:string map_headers:map str_body:string val_httpcode:reference map_respheaders:reference str_respbody:reference
# This procedure allows to execute an External Functionality described through
# an "HTTP-called Functionality" Attribute Profile and provides the result of
# the HTTP call.
# Currently only normal HTTP calls (with or without basic authentication) are
# possible.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#  - id_functionobj - the id of the attribute profile describing the called
#       functionality.
#  - val_skipprecode - if true (1) the pre-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - val_skippostcode - if true (1) the post-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - str_endpoint - allows to override the used endpoint. Leave empty ("") to
#       use the endpoint specified in the referenced attribute profile. If the
#       endpoint provided through the parameter starts with an "@" then it will
#       be appended in addition to the endpoint provided in the attribute
#       profile (minus the @).
#  - str_method - allows to override the used method. Leave empty ("") to use
#       the method specified in the referenced attribute profile.
#  - str_auth - allows to override the used authentication. Leave empty ("") to
#       use the authentication mode specified in the referenced attribute
#       profile. Currently only "Basic" and "None" are supported.
#  - str_username - allows to override the used username during authentication.
#       Leave empty ("") to use the username specified in the referenced
#       attribute profile.
#  - str_password - allows to override the used password during authentication.
#       Leave empty ("") to use the password specified in the referenced
#       attribute profile.
#  - map_headers - specifies which headers should be used in the HTTP call.
#       Both keys and values should be of type string.
#       Note that those can be overwritten by the pre-processing code if not
#       disabled.
#  - str_body - specifies the body that is sent in the HTTP call.
#       Note that those can be overwritten by the pre-processing code if not
#       disabled.
#  - val_httpcode - a reference that will contain the returned status code
#       of the HTTP call as an integer.
#  - map_respheaders - a reference that will contain the headers of the
#       response as a map. Both keys and values are strings.
#  - str_respbody - a reference that will contain the body/content of the
#       response as a string. Since the HTTP-call uses NUL terminated strings
#       (\0) the response can be cut short in some cases (e.g. byte data).
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_generichttp) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_generichttp)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # We also have a small "hack" where an endpoint starting with @ (which shouldn't be?) will replace the @ with the endpoint specified in the attribute profile
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (str_endpoint = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_endpoint)
    SETL str_endpoint:(val)
  } ELSIF ((str_endpoint SUB 0) = "@") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_endpoint)
    SETL str_endpoint:(replace(str_endpoint, "@", val))
  }
  IF (str_method = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_method)
    SETL str_method:(val)
  }
  IF (str_auth = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_auth)
    SETL str_auth:(val)
  }
  IF (str_username = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_uname)
    SETL str_username:(val)
  }
  IF (str_password = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_passwd)
    SETL str_password:(val)
  }
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")

  # For the "Generic" HTTP call we use the code provided as is (unless we're supposed to skip it)
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genhttp_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genhttp_postproc)
    SETL str_postcallcode:(val)
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Since calling services can take quite some time we show the Message Window
  CC "AdoScript" MSGWIN ("Calling service ...")

  # Perform the HTTP call
  #TODO the HttpRequest thing actually has many more options ... extend this to also include them.
  IF (str_auth = "Basic") {
    HTTP_SEND_AUTH_REQUEST (str_endpoint) str_method:(str_method) str_username:(str_username) str_password:(str_password) map_reqheaders:(map_headers) str_reqbody:(str_body) val_respcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
  } ELSE {
    HTTP_SEND_REQUEST (str_endpoint) str_method:(str_method) map_reqheaders:(map_headers) str_reqbody:(str_body) val_respcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
  }
  CC "AdoScript" MSGWIN hide

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }
}

#------------------------------------------------------------------------------
PROCEDURE global EXECAP_HTTP_CALL integer:id_functionobj val_httpcode:reference map_respheaders:reference str_respbody:reference
# This procedure allows to quickly execute an External Functionality described
# through an "HTTP-called Functionality" Attribute Profile and provides the
# result of the HTTP call.
# Currently only normal HTTP calls (with or without basic authentication) are
# possible.
# For more control over certain aspects use EXECAP_HTTP_CALL_OVERRIDE.
#  - id_functionobj - the id of the attribute profile describing the called
#       functionality.
#  - val_httpcode - a reference that will contain the returned status code
#       of the HTTP call as an integer.
#  - map_respheaders - a reference that will contain the headers of the
#       response as a map. Both keys and values are strings.
#  - str_respbody - a reference that will contain the body/content of the
#       response as a string. Since the HTTP-call uses NUL terminated strings
#       (\0) the response can be cut short in some cases (e.g. byte data)
#------------------------------------------------------------------------------
{
  EXECAP_HTTP_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) str_endpoint:("") str_method:("") str_auth:("") str_username:("") str_password:("") map_headers:(map()) str_body:("") val_httpcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_SYSTEM_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer str_command:string str_commandtype:string val_showcmd:integer map_sys_inputvars:map str_sys_inputvarskeys:string map_sys_outputvars:reference str_sys_output:reference str_sys_errors:reference
# This procedure allows to execute an External Functionality described through
# a "System-called Functionality" Attribute Profile and provides the result.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#  - map_sys_outputvars - should be a map where the keys specify the variables
#       that are wanted and the value in their map should specify an expression
#       how to get their value (e.g. a variable name, but more complex things
#       might also be possible).
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericsys) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericsys)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (str_command = "" OR str_commandtype = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_sys_cmd)
    SETL str_cmdpar:(val)
    IF (str_command = "") {
      SETL val_fq:(search(str_cmdpar, "param:\"", 0)+7)
      SETL str_command:(copy(str_cmdpar, val_fq, (LEN str_cmdpar)-val_fq-1))
    }
    IF (str_commandtype = "") {
      SETL val_fq:(search(str_cmdpar, "\"", 0)+1)
      SETL str_commandtype:(copy(str_cmdpar, val_fq, search(str_cmdpar, "\"", val_fq)-val_fq))
    }
  }
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gensys_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gensys_postproc)
    SETL str_postcallcode:(val)
  }

  # Load in the input
  # If no keys have been specifically provided, then we try to read them out of the map!
  IF (str_sys_inputvarskeys = "") { SETL str_sys_inputvarskeys:(mapKeysList(map_sys_inputvars)) }
  FOR str_sys_key in:(str_sys_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_sys_inputvars[str_sys_key]) = "string") {
      EXECUTE ("SETL " + str_sys_key + ":(\"" + map_sys_inputvars[str_sys_key] + "\")") scope:same
    } ELSIF (type(map_sys_inputvars[str_sys_key]) <> "undefined") {
      EXECUTE ("SETL " + str_sys_key + ":(" + STR map_sys_inputvars[str_sys_key] + ")") scope:same
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Now we process the Arguments table
  SETL str_sys_args:("")
  CC "Core" GET_REC_ATTR_ROW_COUNT objid:(id_functionobj) attrid:(global_id_execap_sys_args)
  SETL val_sys_argscount:(count)
  FOR i from:1 to:(val_sys_argscount) {
    CC "Core" GET_REC_ATTR_ROW_ID objid:(id_functionobj) attrid:(global_id_execap_sys_args) index:(i)
    CC "Core" GET_ATTR_VAL objid:(rowid) attrname:(global_str_execap_argsprefconst) as-string
    IF (ecode = 0 AND val <> "") {
      SETL str_sys_args:(str_sys_args + " " + val)
    }
    CC "Core" GET_ATTR_VAL objid:(rowid) attrname:(global_str_execap_argsvarval) as-string
    IF (ecode = 0 AND val <> "") {
      EXECUTE ("SETL str_sys_args:(str_sys_args + \" \" + lam_toString(" + val + "))") scope:same
    }
  }

  # We only execute if there is a command or at least arguments (maybe someone had the "good" idea of putting the command in through arguments?
  IF (str_command <> "" OR str_sys_args <> "") {
    # Depending on what type of execution this is we handle it differently.
    # "Synchronous CMD", "Asynchronous CMD", "Application"
    IF (str_commandtype = global_str_execap_sys_cmd_synchcmd OR str_commandtype = global_str_execap_sys_cmd_asynchcmd) {
      IF (val_showcmd < 0) {
        CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_sys_showcmd)
        SETL val_showcmd:(val)
      }
      # We get two file names to store the result of the cmd call in them
      CC "AdoScript" GET_TEMP_FILENAME
      SETL str_sys_outputfile:(filename)
      CC "AdoScript" GET_TEMP_FILENAME
      SETL str_sys_errorfile:(filename)
      # In Synchronous cases we use SYSTEM and read the file results directly
      IF (str_commandtype = global_str_execap_sys_cmd_synchcmd) {
        IF (val_showcmd) { # The eval(...) is necessary to properly interpret any escape characters in ADOxx (e.g. \\ --> \)
          SYSTEM ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile) with-console-window
        } ELSE {
          SYSTEM ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile)
        }
        CC "AdoScript" FREAD file:(str_sys_outputfile)
        SETL str_sys_output:(text)
        CC "AdoScript" DELETE_FILES (str_sys_outputfile)
        CC "AdoScript" FREAD file:(str_sys_errorfile)
        SETL str_sys_errors:(text)
        CC "AdoScript" DELETE_FILES (str_sys_errorfile)
      } ELSE { # Otherwise it's asynchronous in which case we use START and return the file names
        IF (val_showcmd) { # The eval(...) is necessary to properly interpret any escape characters in ADOxx (e.g. \\ --> \)
          START ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile) cmdshow:shownormal
        } ELSE {
          START ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile) cmdshow:showminnoactive
        }
        SETL str_sys_output:(str_sys_outputfile)
        SETL str_sys_errors:(str_sys_errorfile)
      }
    } ELSIF (str_commandtype = global_str_execap_sys_cmd_app) {
      START (eval("\"" + str_command + "\"") + str_sys_args) cmdshow:shownormal
      # I don't know of any way to communicate reliably with an Application other than cmd soooooo we just leave the two empty
      SETL str_sys_output:("")
      SETL str_sys_errors:("")
    }
  }

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }

  # Load the output into the variable, but only if it's a map
  IF (type(map_sys_outputvars) = "map") {
    SETL str_sys_keys:(mapKeysList(map_sys_outputvars))
    FOR str_sys_key in:(str_sys_keys) sep:("~") {
      # We put the values into the output map. Easiest way to do that is using eval.
      SETL map_sys_outputvars[str_sys_key]:(try(eval(map_sys_outputvars[str_sys_key]), undefined))
    }
  } ELSE { # If it's not a map (whyever) then we set it to an empty map
    SETL map_sys_outputvars:(map())
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_SYSTEM_CALL integer:id_functionobj
# This procedure allows to execute an External Functionality described through
# a "System-called Functionality" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_SYSTEM_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL temp_emptymap:(map())
  EXECAP_SYSTEM_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) str_command:("") str_commandtype:("") val_showcmd:(-1) map_sys_inputvars:(temp_emptymap) str_sys_inputvarskeys:("") map_sys_outputvars:temp_emptymap str_sys_output:dummy str_sys_errors:dummy
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_OLIVE_SERVICE_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer str_endpoint:string str_microserviceid:string str_microservicename:string str_operationid:string val_usesimpleinput:integer map_input:map any_serviceresponse:reference
# This procedure allows to execute an External Functionality described through
# an "Call Operation (Olive)" Attribute Profile and provides the result.
# Currently only normal HTTP calls (with or without basic authentication) are
# possible.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#  - id_functionobj - the id of the attribute profile describing the called
#       functionality.
#  - val_skipprecode - if true (1) the pre-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - val_skippostcode - if true (1) the post-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - str_endpoint - allows to override the used endpoint. Leave empty ("") to
#       use the endpoint specified in the referenced attribute profile. If the
#       endpoint provided through the parameter starts with an "@" then it will
#       be appended in addition to the endpoint provided in the attribute
#       profile (minus the @).
#  - str_microserviceid - allows to override the used microservice ID. Leave
#       empty ("") to use the ID specified in the referenced attribute profile.
#       Typically a UUID (often without the {}), but other values are possible.
#  - str_microservicename - allows to override the used microservice name.
#       Leave empty ("") to use the name specified in the referenced attribute
#       profile. The name is only used when no Microservice ID has been found.
#  - str_operationid - allows to override the used operation ID. Leave empty
#       ("") to use the ID specified in the referenced attribute profle. Often
#       the operation ID is the same as its name.
#  - val_usesimpleinput - allows to override the style of input map to use. Use
#       a negative number to use the value specified in the referenced
#       attribute profile. See further below for more details
#  - map_input - allows to specify a map with the input values to use. Note
#       that any default values specified in the "Input parameters" of the
#       referenced attribute profile are added to the map IF their names are
#       not yet located in the map (i.e. the name as key is undefined).
#  - any_serviceresponse - a reference that will contain the result from
#       calling the service using the best fitting datatype. In case the
#       service has failed it can contain some error information.
#
# Input simplified structure:
# {
#   "gitlab_url": "http://192.168.0.42:8080",
#   "gitlab_project_id": 162
# }
# Input structure expected by Olive MSC:
# {
#   "gitlab_url": {
#     "value": "http://192.168.0.42:8080"
#   },
#   "gitlab_project_id": {
#     "value": "162"
#   }
# }
# Note that in both cases the map has to be simple, i.e. the values should not
# be arrays or maps. This is due to the interface the Olive MSC provides. If
# necessary transform complex values to JSON strings using the mapToJson(myMap)
# or arrayToJson(myArray) functions.
#
# Sets ecode for errors. If it failed due to an HTTP status code then it will
# have that status code.
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericolive) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericolive)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases.
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (str_endpoint = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_endpoint)
    SETL str_endpoint:(val)
  } ELSIF ((str_endpoint SUB 0) = "@") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_endpoint)
    SETL str_endpoint:(replace(str_endpoint, "@", val))
  }
  IF (str_microserviceid = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_microserviceid)
    SETL str_microserviceid:(val)
  }
  IF (str_microservicename = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_microservicename)
    SETL str_microservicename:(val)
  }
  IF (str_operationid = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_operationid)
    SETL str_operationid:(val)
  }
  IF (val_usesimpleinput < 0) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_simpleinput)
    SETL val_usesimpleinput:(val)
  }
  # Making sure that those two have a value.
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_postproc)
    SETL str_postcallcode:(val)
  }

  # Add to the map_input all the default values if they aren't alreay present.
  CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_functionobj) attrid:(global_id_execap_olive_inputparameters)
  FOR str_rowid in:(rowids) {
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_inname) as-string
    SETL str_inparmname:(val)
    IF (type(map_input[str_inparmname]) = "undefined") {
      CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_indefault) as-string
      IF (val_usesimpleinput) {
        SETL map_input[str_inparmname]:(eval(val))
      } ELSE {
        SETL map_input[str_inparmname]:({"value": lam_toString(eval(val))})
      }
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Since calling services can take quite some time we show the Message Window
  CC "AdoScript" MSGWIN ("Calling service ...")

  # Call the Service available through the Olive MSC
  SETG ecode:(0)
  IF (str_microserviceid = "") {
    OLIVE_MSC_GET_MICROSERVICE_ID mscRestUrl:(str_endpoint) microserviceName:(str_microservicename) microserviceId:str_microserviceid
  }
  IF (NOT ecode) {
    # Transform the map_input into the correct JSON string.
    IF (val_usesimpleinput) {
      SETL str_inputstring:(mapToOliveJson(map_input))
    } ELSE {
      SETL str_inputstring:(mapToJson(map_input))
    }
    OLIVE_MSC_CALL_MICROSERVICE_ID_OPERATION mscRestUrl:(str_endpoint) microserviceId:(str_microserviceid) operationId:(str_operationid) input:(str_inputstring) response:any_serviceresponse
  }

  CC "AdoScript" MSGWIN hide

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_OLIVE_SERVICE_CALL integer:id_functionobj any_serviceresponse:reference
# This procedure allows to execute an External Functionality described through
# a "Call Operation (Olive)" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_OLIVE_SERVICE_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL str_dummyresult:("")
  EXECAP_OLIVE_SERVICE_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) str_endpoint:("") str_microserviceid:("") str_microservicename:("") str_operationid:("") val_usesimpleinput:(-1) map_input:(map()) any_serviceresponse:any_serviceresponse
}



##### BEE-UP SPECIFIC START

#------------------------------------------------------------------------------
PROCEDURE global EXECAP_COMPLEX_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer val_comp_execdepth:integer id_comp_start:integer val_comp_delay:real val_comp_output:integer val_comp_debug:integer map_comp_inputvars:map str_comp_inputvarskeys:string map_comp_outputvars:reference str_comp_stdout:reference str_comp_debout:reference
# This procedure allows to execute an External Functionality described through
# a "Complex Functionality" Attribute Profile and provides the result.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericcomp) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericcomp)
    EXIT
  }
  # We might have to load some model if it isn't loaded.
  SETL id_unloadmodel:(-1)

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (id_comp_start <= 0) {
    # Getting the ID of the staring object is a bit more complicated
    CC "Core" GET_INTERREF objid:(id_functionobj) attrname:(global_str_execap_comp_refstart) index:(0)
    IF (ecode = 0) { # ecode is not 0 for example when there is no reference.
      SETL id_refmod:(tmodelid)
      CC "Core" IS_MODEL_LOADED modelid:(id_refmod)
      IF (NOT isloaded) {
        CC "Core" LOAD_MODEL modelid:(id_refmod)
        IF (ecode = 0) {
          SETL id_unloadmodel:(id_refmod)
          CC "Core" GET_INTERREF objid:(id_functionobj) attrname:(global_str_execap_comp_refstart) index:(0)
        }
      }
      SETL id_comp_start:(tobjid)
    }
  }
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gencomp_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gencomp_postproc)
    SETL str_postcallcode:(val)
  }

  # Load in the input
  # If no keys have been specifically provided, then we try to read them out of the map, which can cause problems (e.g. maps in maps)!
  IF (str_comp_inputvarskeys = "") { SETL str_comp_inputvarskeys:(mapKeysList(map_comp_inputvars)) }
  FOR str_comp_key in:(str_comp_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_comp_inputvars[str_comp_key]) = "string") {
      EXECUTE ("SETL " + str_comp_key + ":(\"" + map_comp_inputvars[str_comp_key] + "\")") scope:same
    } ELSIF (type(map_comp_inputvars[str_comp_key]) <> "undefined") {
      EXECUTE ("SETL " + str_comp_key + ":(" + STR map_comp_inputvars[str_comp_key] + ")") scope:same
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # We load the variables back into the map_comp_inputvars, since Pre-processing MIGHT have changed them.
  FOR str_comp_key in:(str_comp_inputvarskeys) sep:("~") {
    SETL map_comp_inputvars[str_comp_key]:(eval(str_comp_key))
  }

  # Add any of the required variables to the map_comp_inputvars and str_comp_inputvarskeys if they are available in this scope but not already part of the map!
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_comp_reqvars) as-string
  SETL str_reqvarsexp:(val)
  FOR str_line in:(str_reqvarsexp) sep:("\n") {
    # Variable I want through: copy(str_line, 0, search(str_line, " : ", 0))
    SETL str_reqvar:(copy(str_line, 0, search(str_line, " : ", 0)))
    IF (type(map_comp_inputvars[str_reqvar]) = "undefined") {
      SETL map_comp_inputvars[str_reqvar]:(eval(str_reqvar))
    }
  }

  IF (val_comp_delay < 0.0) { SETL val_comp_delay:(0.0) }
  IF (val_comp_output < -1 OR val_comp_output > 3) { SETL val_comp_output:(0) }
  IF (val_comp_debug < -1 OR val_comp_debug > 3) { SETL val_comp_debug:(0) }
  FC_EXEC_FC (id_comp_start) val_fc_delay:(val_comp_delay) val_fc_output:(val_comp_output) val_fc_debug:(val_comp_debug) val_fc_execdepth:(val_comp_execdepth) val_fc_printtimes:(0) val_fc_highlight:(0) map_fc_inputvars:(map_comp_inputvars) str_fc_inputvarskeys:(str_comp_inputvarskeys) map_fc_outputvars:map_comp_outputvars str_fc_stdout:str_comp_stdout str_fc_debout:str_comp_debout
  
  # Make the returned variables available in this scope. Each line contains the name of one variable
  # Note: Since the Post-processing code is specified from the point of view of the Attribute Profile, and directly executing the Attribute Profile doesn't use the passed output variables references, we don't have to make them here available, because the code shouldn't know about any of them anyway.
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_comp_retvars) as-string
  SETL str_retvarsexp:(val)
  FOR str_line in:(str_retvarsexp) sep:("\n") {
    SETL str_comp_outactualtype:(type(map_comp_outputvars[str_line]))
    IF (str_comp_outactualtype = "string") {
      EXECUTE ("SETL " + str_line + ":(\"" + map_comp_outputvars[str_line] + "\")") scope:same
    } ELSIF (str_comp_outactualtype = "undefined") {
      EXECUTE ("SETL " + str_line + ":(undefined)") scope:same
    } ELSE {
      EXECUTE ("SETL " + str_line + ":(" + STR map_comp_outputvars[str_line] + ")") scope:same
    }
  }

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }

  # Update the "returned values" in the map_comp_outputvars after the Post-processing, since the Post-processing might have changed their values.
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_comp_retvars) as-string
  SETL str_retvarsexp:(val)
  FOR str_line in:(str_retvarsexp) sep:("\n") {
    SETL map_comp_outputvars[str_line]:(eval(str_line))
  }

  IF (id_unloadmodel > -1) {
    SETL temp_ecode:(ecode) # We want to preserve the ecode after discarding the model
    CC "Core" DISCARD_MODEL modelid:(id_unloadmodel)
    SETG ecode:(temp_ecode)
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_COMPLEX_CALL integer:id_functionobj
# This procedure allows to execute an External Functionality described through
# a "Complex Functionality" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_COMPLEX_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL temp_emptymap:(map())
  EXECAP_COMPLEX_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) val_comp_execdepth:(1) id_comp_start:(-1) val_comp_delay:(0.0) val_comp_output:(0) val_comp_debug:(0) map_comp_inputvars:(map()) str_comp_inputvarskeys:("") map_comp_outputvars:temp_emptymap str_comp_stdout:dummy str_comp_debout:dummy
}

##### BEE-UP SPECIFIC END


# ASC_GlobalProcedures_ExecuteFlowchart

# Version: 1.2.0
# Date: 2022-01-18

# This file contains global procedures to execute Flowcharts.


### Direct Dependencies:
# * ASC_GlobalFunctions_Conversion.asc
# * ASC_GlobalFunctions_MapSupport.asc
# * ASC_GlobalFunctions_StringSupport.asc
# * ASC_GlobalProcedures_ExecAttrProf-beeup.asc
# * ASC_GlobalVariables_FC.asc


# The procedures use the ecode to inform about errors that happen.
# However ecode from CC seems to be "kind of local" unless we make it global.
SETG ecode:(0)
# Same for errtext
SETG errtext:("")



#------------------------------------------------------------------------------
FUNCTION fc_replaceAllOperationShorthandsLineStart:global str_text:string str_keyword:string str_pattern:string
# Replaces every line in str_text starting with str_keyword (and possible
# spaces at the beginning of the line) using the provided str_pattern.
# Use @@@ in the pattern to indicate where everything after str_keyword until
# the end of the line will be inserted. Note that the inserted part is first
# trimmed. str_keyword should not contain the newline character "\n".
#------------------------------------------------------------------------------
return:(
  set(nae, 0),
  while(set(nam, search(str_text, str_keyword, nae))>=0, (
    set(nas, bsearch(str_text, "\n", nam)),
    set(nas, cond(nas<0, 0, nas+1)),
    set(nae, search(str_text, "\n", nam)),
    cond(copy(str_text, nas, nam-nas).trim()="", set(str_text, replaceTextInArea(str_text, nas, nae, replall(str_pattern, "@@@", copy(str_text, nam+(LEN str_keyword), nae-nam-(LEN str_keyword)).trim()))), 0)
  ),
  str_text)
)



#------------------------------------------------------------------------------
FUNCTION fc_replaceAllOperationShorthandsLineMiddle:global str_text:string str_keyword:string str_pattern:string
# Replaces every line in str_text which contains str_keyword somewhere in the
# middle using the provided str_pattern.
# Use @@l@@ in the pattern to indicate where everything before str_keyword and
# @@r@@ where everything after str_keyword should be will be inserted, both
# @@l@@ and @@r@@ will use the content from the str_keywurd until the beginning
# or end of the line. Note that the inserted part is first trimmed. str_keyword
# should not contain the newline character "\n".
#------------------------------------------------------------------------------
return:(
  set(nae, 0),
  while(set(nam, search(str_text, str_keyword, nae))>=0, (
    set(nas, bsearch(str_text, "\n", nam)),
    set(nas, cond(nas<0, 0, nas+1)),
    set(nae, search(str_text, "\n", nam)),
    set(str_text, replaceTextInArea(str_text, nas, nae, replall(replall(str_pattern, "@@r@@", copy(str_text, nam+(LEN str_keyword), nae-nam-(LEN str_keyword)).trim()), "@@l@@", copy(str_text, nas, nam-nas).trim())))
  ),
  str_text)
)



#------------------------------------------------------------------------------
FUNCTION fc_replaceAllAssignmentOperations:global str_text:string str_keyword:string str_pattern:string
# Replaces every line in str_text which contains str_keyword somewhere in the
# middle using the provided str_pattern. Also checks if the part to the left
# is a valid variable name using regular expressions before replacing.
# Use @@l@@ in the pattern to indicate where everything before str_keyword and
# @@r@@ where everything after str_keyword should be will be inserted, both
# @@l@@ and @@r@@ will use the content from the str_keywurd until the beginning
# or end of the line. Note that the inserted part is first trimmed. str_keyword
# should not contain the newline character "\n".
#------------------------------------------------------------------------------
return:(
  set(nae, 0),
  while(set(nam, search(str_text, str_keyword, nae))>=0, (
    set(nas, bsearch(str_text, "\n", nam)),
    set(nas, cond(nas<0, 0, nas+1)),
    set(nae, search(str_text, "\n", nam)),
    set(left, copy(str_text, nas, nam-nas).trim()),
    cond(regex("^([a-zA-Z_])([a-zA-Z0-9_])*(\\[(.)+\\])?$", left), set(str_text, replaceTextInArea(str_text, nas, nae, replall(replall(str_pattern, "@@r@@", copy(str_text, nam+(LEN str_keyword), nae-nam-(LEN str_keyword)).trim()), "@@l@@", left))), 0)
  ),
  str_text)
)



#------------------------------------------------------------------------------
PROCEDURE global FC_EXEC_FC_FROM_START integer:id_start int_userinput:integer map_fc_outputvars:reference str_fc_stdout:reference str_fc_debout:reference
# Executes a Flowchart starting at a Start Terminal. Assumes that the
# operation code and decision expressions are AdoScript. Also uses
# FC_PARESE_OPCODE to allow simplified commands.
# Handles some of the special parts when beginnig at a Start Terminal, like
# checking and asking the user to specify input variable values or reading all
# the execution specific details from the Start Terminal.
#  - id_start - the element where the execution should start.
#  - int_userinput - if true then the Start Terminal will ask the user to
#       provide the input values for the variables, otherwise it will use
#       default values found.
#  - map_fc_outputvars - this is a reference to a map, which is used to return
#       some variables and their values so they can be accessed outside of the
#       scope of this procedure. When passing the map to this procedure the
#       value of each key should hold a variable name (or some simple
#       expression), which will be evaluated at the end of this procedure and
#       its result put into this map under the same key.
#       Note that some expressions might not work because the keys are
#       determined using a custom function. However, if both the key and the
#       value of the passed map are names of variables then everything should
#       work out fine.
#  - str_fc_stdout - any properly written standard output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#  - str_fc_debout - any properly written debug output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#------------------------------------------------------------------------------
{
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_execdelay) as-string
  SETL int_fc_delay:(VAL val)
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_debugconsole) as-string
  IF (val = "yes") { SETL int_fc_debug:(3) } ELSE { SETL int_fc_debug:(-1) }
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_printtimes) as-string
  IF (val = "yes") { SETL int_fc_printtimes:(1) } ELSE { SETL int_fc_printtimes:(0) }
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_highlight) as-string
  IF (val = "yes") { SETL int_fc_highlight:(1) } ELSE { SETL int_fc_highlight:(0) }

  # Ask the user for any required variables that don't have a default value
  SETL map_invars:(map())
  SETL str_invarkeys:("")
  CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_start) attrid:(global_id_fc_reqvars)
  FOR str_rowid in:(rowids) {
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_name) as-string
    SETL str_varname:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_type) as-string
    SETL str_vartype:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_def) as-string
    SETL str_vardef:(val)
    IF (str_vartype = "any" OR str_vartype = "defined") {
      IF (int_userinput) {
        IF (str_vardef = "") {
          SETL str_vardef:("Replace this with the desired value in proper format (i.e. strings should be surrounded by \") for " + str_varname)
        }
        CC "AdoScript" EDITBOX text:(str_vardef) title:("Enter value for " + str_varname)
        IF (endbutton <> "ok") { EXIT }
      }
    } ELSIF (str_vartype = "string" OR str_vartype = "map" OR str_vartype = "array") {
      IF (int_userinput) {
        IF (str_vardef = "") {
          SETL str_vardef:("Replace this with the desired " + str_vartype + " value for " + str_varname)
        }
      }
      IF (str_vartype = "string") {
        IF ((str_vardef SUB 0) = "\"") {
          SETL str_vardef:(copy(str_vardef, 1, -1))
        }
        IF ((str_vardef SUB ((LEN str_vardef)-1)) = "\"") {
          SETL str_vardef:(copy(str_vardef, 0, (LEN str_vardef)-1))
        }
      }
      IF (int_userinput) {
        CC "AdoScript" EDITBOX text:(str_vardef) title:("Enter " + str_vartype + " value for " + str_varname)
        IF (endbutton <> "ok") { EXIT }
      }
    } ELSE {
      IF (int_userinput) {
        CC "AdoScript" EDITFIELD caption:("Enter a value of type " + str_vartype + " for " + str_varname) title:("Enter " + str_vartype + " value for " + str_varname) text:(str_vardef)
        IF (ecode) { EXIT }
      }
    }
    IF (str_vartype = "string") {
      EXECUTE ("SETL map_invars[\"" + str_varname + "\"]:(\"" + text + "\")") scope:same
    } ELSE {
      EXECUTE ("SETL map_invars[\"" + str_varname + "\"]:(" + text + ")") scope:same
    }
    SETL str_invarkeys:(tokcat(str_invarkeys, str_varname, "~"))
  }

  FC_EXEC_FC (id_start) val_fc_delay:(int_fc_delay) val_fc_output:(3) val_fc_debug:(int_fc_debug) val_fc_execdepth:(1) val_fc_printtimes:(int_fc_printtimes) val_fc_highlight:(int_fc_highlight) map_fc_inputvars:(map_invars) str_fc_inputvarskeys:(str_invarkeys) map_fc_outputvars:map_fc_outputvars str_fc_stdout:str_fc_stdout str_fc_debout:str_fc_debout
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX ("Some error occurred while executing the Flowchart:\n" + errtext)
    EXIT
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_EXEC_FC integer:fc_id_startelement val_fc_delay:real val_fc_output:integer val_fc_debug:integer val_fc_execdepth:integer val_fc_printtimes:integer val_fc_highlight:integer map_fc_inputvars:map str_fc_inputvarskeys:string map_fc_outputvars:reference str_fc_stdout:reference str_fc_debout:reference
# Executes a Flowchart starting at a specific element. Assumes that the
# operation code and decision expressions are AdoScript. Also uses
# FC_PARESE_OPCODE to allow simplified commands.
# Additionally it contains some UI stuff as well (pup-up window to cancel
# execution, output window to print to etc.) so it is not just the execution.
#  - fc_id_startelement - the element where the execution should start. Can be
#       something else besides a Start Terminal.
#  - val_fc_delay - number of seconds to wait before executing the next element.
#       Useful to show how the Flowchart is executed. Will be rounded to tenths
#       of a second.
#  - val_fc_output - specifies the standard output behavior. In any case output
#       will be appended to str_fc_stdout. If -1 then the output window will be
#       closed and not used (careful, this can influence other executions!). If
#       0 then the output window will be left alone and output will only be
#       appended to str_fc_stdout. If 1 then it will use the output window
#       should it exist. Note that even if an output window isn't visible it
#       might still exist. If 2 then it will reuse (append to) the available
#       output window or create one if not available. It makes sure that the
#       window is visible. If 3 it will reset the output window or create it if
#       not available and use it.
#       Note: The Standard and Debug output windows are separate!
#  - val_fc_debug - specifies the debug output behavior. In any case debug info
#       will be appended to str_fc_debout. If -1 then the debug window will be
#       closed and not used (careful, this can influence other executions!). If
#       0 then the debug window will be left alone and debug info will only be
#       appended to str_fc_debout. If 1 then it will use the debug window
#       should it exist. Note that even if an debug window isn't visible it
#       might still exist. If 2 then it will reuse (append to) the available
#       debug window or create one if not available. It makes sure that the
#       window is visible. If 3 it will reset the debug window or create it if
#       not available and use it.
#       Note: The Standard and Debug output windows are separate!
#  - val_fc_execdepth - specifies at which depth we are currently executing.
#       Here because we use this procedure recursively.
#  - val_fc_printtimes - if true (1) then any passed Start Terminal and End
#       Terminal will print START/END as well as a timestamp to the output
#       window.
#  - val_fc_highlight - if true (1) then the currently executed element will be
#       shown, selected and highlighted in the model.
#  - map_fc_inputvars - this map is used to pass some variables with their
#       values into the scope of this procedure. They will be set as local
#       variables in this procedure. The keys of the map should specify the
#       name of the variable and the values of the map should be the value for
#       that variable.
#  - str_fc_inputvarskeys - this variable should contain all the valid keys of
#       the map_fc_inputvars map, separated by ~ signs. If it is left empty
#       then the procedure will try to guess all the keys, which can cause
#       problems in some cases (e.g. when a value is also a map).
#  - map_fc_outputvars - this is a reference to a map, which is used to return
#       some variables and their values so they can be accessed outside of the
#       scope of this procedure. When passing the map to this procedure the
#       value of each key should hold a variable name (or some simple
#       expression), which will be evaluated at the end of this procedure and
#       its result put into this map under the same key.
#       Note that some expressions might not work because the keys are
#       determined using a custom function. However, if both the key and the
#       value of the passed map are names of variables then everything should
#       work out fine.
#  - str_fc_stdout - any properly written standard output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#  - str_fc_debout - any properly written debug output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#------------------------------------------------------------------------------
{
  #TODO currently "calling" a different flowchart model does not show it in the modeling toolkit. Maybe provide an option to "Open" and jump to any executed "sub-models" instead of just doing them in the background? hmmm maybe if I'd use something like val_fc_highlight to specify the depth and every time we go deeper we -- it, 0 would mean "don't highlight" and -1 would mean "infinite depth.
  #TODO currently there are so many calls to ADOxx Message Ports after an error in the executed code has happened that they overwrite the errtext if an error occurred. Should probably save that errtext so it is available also to the next operation. One example when providing a "string" for READN and the operation that follows the "success = 0") route prints: There was an error entering the variable: CORE_NO_ERROR

  # Make sure that these two are of the proper type.
  IF (type(str_fc_stdout) <> "string") {
    SETL str_fc_stdout:("")
  }
  IF (type(str_fc_debout) <> "string") {
    SETL str_fc_debout:("")
  }
  # We also specify starting values for these two local variables so that we can ignore ecode / errtext in certain parts.
  SETL val_fc_lastecodebeforeexec:(0)
  SETL str_fc_lasterrtextbeforeexec:("")

  # For the case where we don't deal with output windows (val_fc_output or val_fc_debug = 0) we don't have to do anything.
  # In most other cases we close the previous output/debug window.
  IF (val_fc_output < 0 OR val_fc_output > 1) {
    CC "AdoScript" CLOSE_DOCKABLE_WINDOW winid:(global_str_fc_outputwin)
  }
  IF (val_fc_debug < 0 OR val_fc_debug > 1) {
    CC "AdoScript" CLOSE_DOCKABLE_WINDOW winid:(global_str_fc_debugwin)
  }

  # Get and store the model id. It is also used for other things beside the output windows.
  CC "Core" GET_MODEL_ID objid:(fc_id_startelement)
  IF (ecode<>0) {
    SETG errtext:("Encountered an error while trying to read the model information. Stopping script now.")
    EXIT
  }
  SETL id_fc_fcmodelid:(modelid)
  # We also have this variable to be available to the modeler, i.e. a variable that is documented and can be accessed by them.
  SETL this_modelid:(id_fc_fcmodelid)

  # Also remove any previous dyes if there are any in the model
  CC "Modeling" UNDYE_ALL modelid:(id_fc_fcmodelid)

  # The case for reuse or reset of the output/debug window opens them back up.
  # There doesn't seem to be a reliable way of checking if an output window is open (at least I don't know any). Also open <> exist! OUT only fails if the window doesn't exist. Which is the reason why we always close and then reopen it.
  CC "Core" GET_MODEL_INFO modelid:(id_fc_fcmodelid)
  IF (val_fc_output >= 2) {
    CC "AdoScript" CREATE_OUTPUT_WIN winid:(global_str_fc_outputwin) title:(global_str_fc_outputwin + " - " + modelname + " " + ver)
  }
  IF (val_fc_debug >= 2) {
    CC "AdoScript" CREATE_OUTPUT_WIN winid:(global_str_fc_debugwin) title:(global_str_fc_debugwin + " - " + modelname + " " + ver)
  }
  # The case for recreating the output/debug windows also clears them.
  IF (val_fc_output = 3) {
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 1
    CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:("\n")
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 10000
  }
  IF (val_fc_debug = 3) {
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 1
    CC "AdoScript" OUT winid:(global_str_fc_debugwin) text:("\n")
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 10000
  }

  # We write this debug line because of the way "new lines" are handled later on ... so it doesn't start with an empty line :)
  FC_DEBUG_OUTPUT_INTERNAL ((STR val_fc_execdepth) + ": " + modelname) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout

  # Here we round the provided delay to a value the script can handle: the amount of 100ms sleeps
  SETL val_fc_delay:(round(val_fc_delay*10))

  # Variables used in the execution
  SETL int_fc_success:(0)
  SETL int_fc_conditionfulfilled:(0)
  SETL any_fc_compareval:("")
  SETL id_fc_curelement:(fc_id_startelement)
  #TODO when changing from "single-path" to "multiple-paths" the id_fc_nextelement will have to change to a string, and also probably in name.
  SETL id_fc_nextelement:(fc_id_startelement)
  SETL val_fc_percent:(0)

  # We use the PERCWIN to allow the user to cancel the execution if it takes to long (e.g. infinite loops).
  # Note that this only takes care of infinite loops in the model, not in the executed code itself!
  CC "AdoScript" PERCWIN_CREATE title:"Flowchart execution" with-cancel-button:1

  # Load in the input into this scope
  # If no keys have been specifically provided, then we try to read them out of the map, which can cause problems (e.g. maps in maps)!
  IF (str_fc_inputvarskeys = "") { SETL str_fc_inputvarskeys:(try(mapKeysList(map_fc_inputvars), "")) }
  FOR str_fc_key in:(str_fc_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_fc_inputvars[str_fc_key]) = "string") {
      EXECUTE ("SETL " + str_fc_key + ":(\"" + map_fc_inputvars[str_fc_key] + "\")") scope:same
    } ELSIF (type(map_fc_inputvars[str_fc_key]) <> "undefined") {
      # Special case because empty maps and arrays look the same.
      IF ((type(map_fc_inputvars[str_fc_key]) = "map") AND try(LEN map_fc_inputvars[str_fc_key] = 0, 0)) {
        EXECUTE ("SETL " + str_fc_key + ":(map())") scope:same
      } ELSE {
        EXECUTE ("SETL " + str_fc_key + ":(" + STR map_fc_inputvars[str_fc_key] + ")") scope:same
      }
    }
  }

  # The returned variables can be different depending on where we start, So this variable will hold a list of variable names separated by "~" that should be returned, unless they are already requested through map_fc_outputvars or their value is undefined.
  SETL ids_fc_retvars:("")

  # This executes the elements one after the other, as long as there is a "follow up" element.
  WHILE (id_fc_nextelement>0) {
    IF (val_fc_highlight) {
      # The DYE and UNDYE are useful to show where the execution has ended (e.g. when it ended prematurely). so we have to update it properly.
      CC "Modeling" UNDYE (id_fc_curelement) error-mark
    }
    # Here we can move on to the next element
    # From this point on, until we determine the next element, id_fc_curelement and id_fc_nextelement should have the same value.
    SETL id_fc_curelement:(id_fc_nextelement)
    # We also have this variable to be available to the modeler, i.e. a variable that is documented and can be accessed by them.
    SETL this_objid:(id_fc_curelement)

    # If the "debug window" is used then we print the name of the next element to execute.
    CC "Core" GET_OBJ_NAME objid:(id_fc_curelement)
    FC_DEBUG_OUTPUT_INTERNAL ("\n" + (STR val_fc_execdepth) + ": " + objname) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout

    # Calculate the next percentage for the percentage window and update it.
    SETL val_fc_percent:(val_fc_percent+1)
    IF (val_fc_percent > 100) {
      SETL val_fc_percent:(0)
    }
    CC "AdoScript" PERCWIN_SET percentage:(val_fc_percent) text:("Press the cancel button to stop the execution.")

    # Only jumps to and highlights the elements if so desired.
    IF (val_fc_highlight) {
      # "Find" the element that is to be executed. The benefit of FIND is that it also moves the view to the position of the element.
      # It is also used before the DYE so it doesn't automatically UNDYE the element.
      CC "Modeling" FIND objid:(id_fc_curelement)
      # The DYE and UNDYE are useful to show where the execution has ended (e.g. when it ended prematurely).
      CC "Modeling" DYE (id_fc_curelement) error-mark make-visible
    }

    # Here we start working on the actual execution. It is important that this code is not "out-sourced" in a separate procedure, so the scope of variables set by the EXECUTE remains intact.
    # Otherwise a more complicated approach using maps to pass inputs and outputs is required that unfortunately can cause problems when having maps in maps.
    # All the variables that are set through code in the model are kept in this scope, thus they are available throughout the model.
    CC "Core" GET_CLASS_ID objid:(id_fc_curelement)
    SETL id_fc_curclsid:(classid)

    # Decide how to continue
    IF (id_fc_curclsid = global_id_fc_start) { # For Start Terminal
      CC "Application" GET_DATE_TIME date-format:"dd/mm/yyyy" time-format:"hh:mm:ss"
      IF (val_fc_printtimes) { # If the start/end times are to be printed
        FC_STANDARD_OUTPUT_INTERNAL ("START @ " + (date) + " " + (time) + "\n") val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout
      }
      FC_DEBUG_OUTPUT_INTERNAL (" @ " + (date) + " " + (time)) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      SETG ecode:(0) # We don't mind if failing to write has a problem here.
      # We also check the required variables and handle them accordingly
      CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_reqvars)
      FOR str_rowid in:(rowids) {
        CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_name) as-string
        SETL str_varname:(val)
        CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_type) as-string
        SETL str_vartype:(val)
        IF (type(eval(str_varname)) = "undefined") { # If the variable simply doesn't exist then we set it to the default value
          CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_def) as-string
          IF (val <> "") {
            EXECUTE ("SETL " + str_varname + ":(" + val + ")") scope:same
          }
        }
        SETL str_fc_truevartype:(type(eval(str_varname)))
        # If the variable doesn't fit the specified type then we crash and burn
        IF ((str_fc_truevartype <> str_vartype AND str_vartype <> "any" AND str_vartype <> "defined" AND str_vartype <> "number") OR (str_vartype = "defined" AND str_fc_truevartype = "undefined") OR (str_vartype = "number" AND str_fc_truevartype <> "integer" AND str_fc_truevartype <> "real")) {
          CC "Core" GET_OBJ_NAME objid:(id_fc_curelement)
          FC_DEBUG_OUTPUT_INTERNAL (" failed, because the required variable " + str_varname + " of " + objname + " is of the wrong type. Expected " + str_vartype + " but found " + str_fc_truevartype + ".") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
          SETG ecode:(420)
          SETG errtext:("The required variable " + str_varname + " of " + objname + " is of the wrong type. Expected " + str_vartype + " but found " + str_fc_truevartype + ".")
          EXIT # Here we exit right away since not much has yet happened and we're supposed to fail.
        }
      }
      # And we store any names of variable that should be returned at the end
      CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_retvars)
      FOR str_rowid in:(rowids) {
        CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_name) as-string
        SETL ids_fc_retvars:(tokcat(ids_fc_retvars, val, "~"))
      }
      SETL int_fc_success:(1)
      FC_DEBUG_OUTPUT_INTERNAL (" (success: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
    } ELSIF (id_fc_curclsid = global_id_fc_operation) { # For Operation
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_opactive) as-string
      IF (val = "yes") {
        # Get the operation attribute and execute it
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_opcode) as-string
        SETL str_fc_opcode:(val)
        # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
        IF (NOT ecode) {
          SETG errtext:(str_fc_lasterrtextbeforeexec)
          SETG ecode:(val_fc_lastecodebeforeexec)
        }
        # The following procedure is used to find some of the "added keywords" and transforms them into normal AdoScript.
        FC_PARESE_OPCODE str_opcode:str_fc_opcode val_fc_output:(val_fc_output)
        EXECUTE (str_fc_opcode) scope:same
        # Store the ecode / errtext from this execution.
        SETL str_fc_lasterrtextbeforeexec:(errtext)
        SETL val_fc_lastecodebeforeexec:(ecode)
        IF (ecode=0) {
          SETL int_fc_success:(1)
        } ELSE {
          SETL int_fc_success:(0)
        }
        FC_DEBUG_OUTPUT_INTERNAL (" (success: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      } ELSE {
        SETL int_fc_success:(1)
      }
    } ELSIF (id_fc_curclsid = global_id_fc_exoperation) { # For External Operation
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopactive) as-string
      IF (val = "yes") {
        # Check what kind of external operation this is and execute it properly
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exoptype) as-string
        SETL str_fc_exoptype:(val)
        # The next IFs checks which type of functionality is called and then reads the correct configuration parameters and uses the proper procedure.
        IF (str_fc_exoptype = global_str_fc_exoptype_undef) {
          # If it isn't specified then we just don't do anything.
        } ELSIF (str_fc_exoptype = global_str_fc_exoptype_http) {
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
          SETL val_skipprecode:(val)
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
          SETL val_skippostcode:(val)
          CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exophttpcall)
          # Restore the ecode / errtext from the previously executed part before we run any code.
          IF (NOT ecode) {
            SETG errtext:(str_fc_lasterrtextbeforeexec)
            SETG ecode:(val_fc_lastecodebeforeexec)
          }
          # We set empty values for everything that isn't defined of the correct type.
          EXECAP_HTTP_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode)
              str_endpoint:(cond(type(str_call_endpoint) <> "string", "", str_call_endpoint))
              str_method:(cond(type(str_call_method) <> "string", "", str_call_method))
              str_auth:(cond(type(str_call_auth) <> "string", "None", str_call_auth))
              str_username:(cond(type(str_call_username) <> "string", "", str_call_username))
              str_password:(cond(type(str_call_password) <> "string", "", str_call_password))
              map_headers:(cond(type(map_call_headers) <> "map", map(), map_call_headers))
              str_body:(cond(type(str_call_body) <> "string", "", str_call_body))
              val_httpcode:val_http_code
              map_respheaders:map_http_respheaders
              str_respbody:str_http_respbody
          # Store the ecode / errtext from this execution.
          SETL str_fc_lasterrtextbeforeexec:(errtext)
          SETL val_fc_lastecodebeforeexec:(ecode)
        } ELSIF (str_fc_exoptype = global_str_fc_exoptype_oliveop) {
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
          SETL val_skipprecode:(val)
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
          SETL val_skippostcode:(val)
          CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopoliveopcall)
          # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
          IF (NOT ecode) {
            SETG errtext:(str_fc_lasterrtextbeforeexec)
            SETG ecode:(val_fc_lastecodebeforeexec)
          }
          # We set empty values for everything that isn't defined of the correct type.
          EXECAP_OLIVE_SERVICE_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode)
              str_endpoint:(cond(type(str_olive_endpoint) <> "string", "", str_olive_endpoint))
              str_microserviceid:(cond(type(str_olive_microserviceid) <> "string", "", str_olive_microserviceid))
              str_microservicename:(cond(type(str_olive_microservicename) <> "string", "", str_olive_microservicename))
              str_operationid:(cond(type(str_olive_operationid) <> "string", "", str_olive_operationid))
              val_usesimpleinput:(cond(type(val_olive_usesimpleinput) <> "integer", -1, val_olive_usesimpleinput))
              map_input:(cond(type(map_olive_input) <> "map", map(), map_olive_input))
              any_serviceresponse:any_olive_result
          # Store the ecode / errtext from this execution.
          SETL str_fc_lasterrtextbeforeexec:(errtext)
          SETL val_fc_lastecodebeforeexec:(ecode)
        } ELSIF (str_fc_exoptype = global_str_fc_exoptype_system OR str_fc_exoptype = global_str_fc_exoptype_model OR str_fc_exoptype = global_str_fc_exoptype_comp OR str_fc_exoptype = global_str_fc_exoptype_asf) { # We merge those together, because they share some similarities, most notably the "Passed Variables" and "Returned Variables".
          # Set up the input map for the "Passed Variables"
          SETL map_call_inputvars:(map())
          SETL str_call_inputvars_keys:("")
          CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_exopinvars)
          FOR str_rowid in:(rowids) {
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_invars_varname) as-string
            SETL str_varname:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_invars_as) as-string
            IF (val <> "") { SETL str_varas:(val) } ELSE { SETL str_varas:(str_varname) }
            SETL map_call_inputvars[str_varas]:(eval(str_varname))
            SETL str_call_inputvars_keys:(tokcat(str_call_inputvars_keys, str_varas, "~"))
          }
          # Set up the output map for the "Returned Variables"
          SETL map_call_outputvars:(map())
          SETL str_call_outputvars_keys:("")
          CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_exopoutvars)
          FOR str_rowid in:(rowids) {
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_outvars_varname) as-string
            SETL str_varname:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_outvars_as) as-string
            IF (val <> "") { SETL str_varas:(val) } ELSE { SETL str_varas:(str_varname) }
            SETL map_call_outputvars[str_varas]:(str_varname)
            SETL str_call_outputvars_keys:(tokcat(str_call_outputvars_keys, str_varas, "~"))
          }
          # This is where the differences between the various types are processed.
          IF (str_fc_exoptype = global_str_fc_exoptype_system) { # For system calls
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
            SETL val_skipprecode:(val)
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
            SETL val_skippostcode:(val)
            # We set "empty" values for everything that isn't defined of the correct type.
            IF (type(str_command) <> "string") { SETL str_command:("") }
            IF (type(str_commandtype) <> "string") { SETL str_commandtype:("") }
            IF (type(val_showcmd) <> "integer") { SETL val_showcmd:(-1) }
            CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopsyscall)
            # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
            IF (NOT ecode) {
              SETG errtext:(str_fc_lasterrtextbeforeexec)
              SETG ecode:(val_fc_lastecodebeforeexec)
            }
            EXECAP_SYSTEM_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode) str_command:(str_command) str_commandtype:(str_commandtype) val_showcmd:(val_showcmd) map_sys_inputvars:(map_call_inputvars) str_sys_inputvarskeys:(str_call_inputvars_keys) map_sys_outputvars:map_call_outputvars str_sys_output:str_sys_output str_sys_errors:str_sys_errors
            # Store the ecode / errtext from this execution.
            SETL str_fc_lasterrtextbeforeexec:(errtext)
            SETL val_fc_lastecodebeforeexec:(ecode)
          } ELSIF (str_fc_exoptype = global_str_fc_exoptype_asf) { # For calls to AdoScript functionality
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
            SETL val_skipprecode:(val)
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
            SETL val_skippostcode:(val)
            # We set empty values for everything that isn't defined of the correct type.
            IF (type(map_call_filelinks) <> "map") { SETL map_call_filelinks:(map()) }
            CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopasfcall)
            # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
            IF (NOT ecode) {
              SETG errtext:(str_fc_lasterrtextbeforeexec)
              SETG ecode:(val_fc_lastecodebeforeexec)
            }
            EXECAP_ADOSCRIPT_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode) map_asf_filelinks:(map_call_filelinks) map_asf_inputvars:(map_call_inputvars) str_asf_inputvarskeys:(str_call_inputvars_keys) map_asf_outputvars:map_call_outputvars
            # Store the ecode / errtext from this execution.
            SETL str_fc_lasterrtextbeforeexec:(errtext)
            SETL val_fc_lastecodebeforeexec:(ecode)
          } ELSIF (str_fc_exoptype = global_str_fc_exoptype_comp) { # For calls to complex functionality
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
            SETL val_skipprecode:(val)
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
            SETL val_skippostcode:(val)
            # Here we process the different possible output-window settings
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopcompoutwins)
            IF (ecode <> 0) {
              IF (type(val_call_output) <> "integer") { SETL val_call_output:(0) }
              IF (type(val_call_debug) <> "integer") { SETL val_call_debug:(0) }
            } ELSIF (val = global_str_fc_exopcompoutwins_ignore) {
              SETL val_call_output:(0)
              SETL val_call_debug:(0)
            } ELSIF (val = global_str_fc_exopcompoutwins_reuseif) {
              SETL val_call_output:(1)
              SETL val_call_debug:(0)
              IF (type(val_fc_debug) = "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(1) } }
            } ELSIF (val = global_str_fc_exopcompoutwins_reusemake) {
              SETL val_call_output:(2)
              SETL val_call_debug:(0)
              IF (type(val_fc_debug) = "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(2) } }
            } ELSIF (val = global_str_fc_exopcompoutwins_reset) {
              SETL val_call_output:(3)
              SETL val_call_debug:(0)
              IF (type(val_fc_debug) = "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(3) } }
            } ELSE {
              IF (type(val_call_output) <> "integer") { SETL val_call_output:(0) }
              IF (type(val_call_debug) <> "integer") { SETL val_call_debug:(0) }
            }
            # We set empty values for everything that isn't defined of the correct type.
            IF (type(val_call_delay) <> "real") { SETL val_call_delay:(0.0) }
            IF (type(id_call_start) <> "integer") { SETL id_call_start:(-1) }
            SETL str_comp_stdout:("")
            SETL str_comp_debout:("")
            CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopcompcall)
            # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
            IF (NOT ecode) {
              SETG errtext:(str_fc_lasterrtextbeforeexec)
              SETG ecode:(val_fc_lastecodebeforeexec)
            }
            EXECAP_COMPLEX_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode) val_comp_execdepth:(val_fc_execdepth+1) id_comp_start:(id_call_start) val_comp_delay:(val_call_delay) val_comp_output:(val_call_output) val_comp_debug:(val_call_debug) map_comp_inputvars:(map_call_inputvars) str_comp_inputvarskeys:(str_call_inputvars_keys) map_comp_outputvars:map_call_outputvars str_comp_stdout:str_comp_stdout str_comp_debout:str_comp_debout
            # Store the ecode / errtext from this execution.
            SETL str_fc_lasterrtextbeforeexec:(errtext)
            SETL val_fc_lastecodebeforeexec:(ecode)
            SETL str_fc_stdout:(str_fc_stdout + str_comp_stdout)
            SETL str_fc_debout:(str_fc_debout + str_comp_debout)
          } ELSIF (str_fc_exoptype = global_str_fc_exoptype_model) { # For referenced models it's a bit different ... hopefully simpler ... NOPE, not simpler.
            # We set values for everything that isn't defined of the correct type, mostly "empty" values.
            IF (type(val_call_delay) <> "real") { SETL val_call_delay:(0.0) }
            IF (type(val_call_output) <> "integer") { IF (val_fc_output > 0) { SETL val_call_output:(1) } ELSE { SETL val_call_output:(0)} }
            IF (type(val_call_debug) <> "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(1) } ELSE { SETL val_call_debug:(0) } }
            IF (type(val_call_printtimes) <> "integer") { SETL val_call_printtimes:(0) }
            IF (type(val_call_highlight) <> "integer") { SETL val_call_highlight:(0) }
            # Getting the ID of the staring object is a bit more complicated
            CC "Core" GET_INTERREF objid:(id_fc_curelement) attrid:(global_id_fc_exoprefmodstart) index:(0)
            IF (ecode = 0) { # ecode is not 0 for example when there is no reference.
              SETL id_refmod:(tmodelid)
              # We have to load the model if it isn't loaded.
              SETL id_unloadmodel:(-1)
              CC "Core" IS_MODEL_LOADED modelid:(id_refmod)
              IF (NOT isloaded) {
                CC "Core" LOAD_MODEL modelid:(id_refmod)
                IF (ecode = 0) {
                  SETL id_unloadmodel:(id_refmod)
                  CC "Core" GET_INTERREF objid:(id_fc_curelement) attrid:(global_id_fc_exoprefmodstart) index:(0)
                }
              }
              IF (tobjid > -1) {
                # Need to add a new line
                # We could've made it this far only if ecode = 0
                FC_DEBUG_OUTPUT_INTERNAL ("\n") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
                SETL str_mod_stdout:("")
                SETL str_mod_debout:("")
                # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
                IF (NOT ecode) {
                  SETG errtext:(str_fc_lasterrtextbeforeexec)
                  SETG ecode:(val_fc_lastecodebeforeexec)
                }
                FC_EXEC_FC (tobjid) val_fc_delay:(val_call_delay) val_fc_output:(val_call_output) val_fc_debug:(val_call_debug) val_fc_execdepth:(val_fc_execdepth+1) val_fc_printtimes:(val_call_printtimes) val_fc_highlight:(val_call_highlight) map_fc_inputvars:(map_call_inputvars) str_fc_inputvarskeys:(str_call_inputvars_keys) map_fc_outputvars:map_call_outputvars str_fc_stdout:str_mod_stdout str_fc_debout:str_mod_debout
                # Store the ecode / errtext from this execution.
                SETL str_fc_lasterrtextbeforeexec:(errtext)
                SETL val_fc_lastecodebeforeexec:(ecode)
                SETL str_fc_stdout:(str_fc_stdout + str_mod_stdout)
                SETL str_fc_debout:(str_fc_debout + str_mod_debout)
              } ELSE {
                SETG ecode:(420)
              }
              IF (id_unloadmodel > -1) {
                SETL temp_ecode:(ecode) # We want to preserve the ecode after discarding the model
                CC "Core" DISCARD_MODEL modelid:(id_unloadmodel)
                SETG ecode:(temp_ecode)
              }
            }
          }
          IF (ecode = 0) {
            # Process the output map
            #TODO if the variables specified to be "returned" from calling a Flowchart/Start Terminal should be added to the output map, we'd have to get them here out of map_call_outputvars and into this scope.
            FOR str_fc_key in:(str_call_outputvars_keys) sep:("~") {
              SETL str_fc_actualtype:(type(map_call_outputvars[str_fc_key]))
              IF (str_fc_actualtype = "string") {
                EXECUTE ("SETL " + str_fc_key + ":(\"" + map_call_outputvars[str_fc_key] + "\")") scope:same
              } ELSIF (str_fc_actualtype = "undefined") {
                EXECUTE ("SETL " + str_fc_key + ":(undefined)") scope:same
              } ELSE {
                EXECUTE ("SETL " + str_fc_key + ":(" + STR map_call_outputvars[str_fc_key] + ")") scope:same
              }
            }
          }
        } ELSE { # If it is some External Operation we don't know how to handle then we consider it an error
          SETG ecode:(420)
        }
        IF (ecode=0) {
          SETL int_fc_success:(1)
        } ELSE {
          SETL int_fc_success:(0)
        }
        FC_DEBUG_OUTPUT_INTERNAL (" (success: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
        # We also print here the returned values to the debug window
        IF (int_fc_success AND (type(str_call_outputvars_keys) = "string")) {
          FOR str_fc_key in:(str_call_outputvars_keys) sep:("~") {
            FC_DEBUG_OUTPUT_INTERNAL ("\n-> returned value for " + str_fc_key + ": " + eval("lam_toString(" + str_fc_key + ")")) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
          }
        }
      } ELSE { # If the External Operation is not active then we simply follow the success path.
        SETL int_fc_success:(1)
      }
    } ELSIF (id_fc_curclsid = global_id_fc_decision) { # For Decision
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_decactive) as-string
      IF (val = "yes") {
        # Get the check expression attribute and execute it
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_deccode) as-string
        # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
        IF (NOT ecode) {
          SETG errtext:(str_fc_lasterrtextbeforeexec)
          SETG ecode:(val_fc_lastecodebeforeexec)
        }
        EXECUTE ("IF(" + val + ") { SETL int_fc_success:(1) } ELSE { SETL int_fc_success:(0) }") scope:same
      } ELSE {
        SETL int_fc_success:(1)
      }
      FC_DEBUG_OUTPUT_INTERNAL (" (decision: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
    } ELSIF (id_fc_curclsid = global_id_fc_switch) { # For Switch
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_switchactive) as-string
      IF (val = "yes") {
        # Get the check expression attribute and execute it
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_switchcode) as-string
        # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
        IF (NOT ecode) {
          SETG errtext:(str_fc_lasterrtextbeforeexec)
          SETG ecode:(val_fc_lastecodebeforeexec)
        }
        EXECUTE ("SETL any_fc_compareval:(" + val + ")") scope:same
        SETL int_fc_success:(-1)
      } ELSE {
        SETL int_fc_success:(1)
      }
      FC_DEBUG_OUTPUT_INTERNAL (" (switch: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
    } ELSIF (id_fc_curclsid = global_id_fc_end) { # For End Terminal
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_endingtype)
      SETL str_endingtype:(val)
      CC "Application" GET_DATE_TIME date-format:"dd/mm/yyyy" time-format:"hh:mm:ss"
      IF (val_fc_printtimes) { # If the start/end times are to be printed
        FC_STANDARD_OUTPUT_INTERNAL ("END (" + str_endingtype + ") @ " + (date) + " " + (time)) val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout
      }
      FC_DEBUG_OUTPUT_INTERNAL (" (" + str_endingtype + ") @ " + (date) + " " + (time)) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      IF (str_endingtype = "Success") {
        SETL str_fc_lasterrtextbeforeexec:("")
        SETL val_fc_lastecodebeforeexec:(0)
        SETL int_fc_success:(1)
      } ELSIF (str_endingtype = "Failure") {
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_enddescription) as-string
        SETL str_fc_lasterrtextbeforeexec:(cond(ecode, "", val)) # Note that this is the ecode from GET_ATTR_VAL
        SETL val_fc_lastecodebeforeexec:(cond(val_fc_lastecodebeforeexec, val_fc_lastecodebeforeexec, 1))
        SETL int_fc_success:(0)
        FC_DEBUG_OUTPUT_INTERNAL (" - " + errtext) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      } ELSE {
        # Otherwise we don't change anything. Restoring the ecode / errtext has to happen later towards the end of the procedure.
      }
    } ELSE { # For everything else, we don't know what to do with it so we just ... continue
      SETL int_fc_success:(1)
    }

    # Next we try to find the following element
    SETL id_fc_nextelement:(0)
    CC "Core" GET_CONNECTORS objid:(id_fc_curelement) out
    IF (ecode <> 0) {
      FC_DEBUG_OUTPUT_INTERNAL ("\nFailed determining the outgoing connectors of the current element. The execution will be aborted.") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      SETL id_fc_nextelement:(-1) # Jump out of the while
    }
    FOR str_fc_outcon in:(objids) {
      CC "Core" GET_CLASS_ID objid:(VAL str_fc_outcon)
      IF (classid=global_id_fc_subsequent) { # Only consider subsequent relations
        # Check if the condition of the relation is met
        CC "Core" GET_ATTR_VAL objid:(VAL str_fc_outcon) attrid:(global_id_fc_gate) as-string
        SETL str_gate:(val.trim())
        IF (str_gate <> "") {
          EXECUTE ("IF(" + str_gate + ") { SETL int_fc_conditionfulfilled:(1) } ELSE { SETL int_fc_conditionfulfilled:(0) }") scope:same
          IF (NOT int_fc_conditionfulfilled) {
            # If not then skip this relation
            FC_DEBUG_OUTPUT_INTERNAL ("\n\t(subsequent condition failed: " + str_gate + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
            NEXT
          }
        }
        # Here the condition of the relation has been tested and is satisfied, so now we check the other cases.
        CC "Core" GET_ATTR_VAL objid:(VAL str_fc_outcon) attrid:(global_id_fc_expres) as-string
        SETL str_exprres:(val)
        IF (int_fc_success < 0) { # when success < 0 then we have to determine the path through the connectors
          IF (str_exprres="true") {
            CC "Core" GET_ATTR_VAL objid:(VAL str_fc_outcon) attrid:(global_id_fc_compare) as-string
            SETL any_temp:(val)
            IF (any_temp <> "") {
              EXECUTE ("SETL any_temp:(" + val + ")") scope:same
            }
            # Compare if the value from the connector evaluates to the same value as is stored in any_fc_compareval
            IF (type(any_temp) = type(any_fc_compareval)) {
              IF (any_temp = any_fc_compareval) {
                CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL str_fc_outcon)
                SETL id_fc_nextelement:(toobjid)
                BREAK
              }
            }
          } ELSE { # basically we treat the relations with "Exprsesion result" = false as the default paths
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL str_fc_outcon)
            SETL id_fc_nextelement:(toobjid)
            # We don't break, because there might be other relations that actually fulfill the condition!
          }
        } ELSE {
          IF ((int_fc_success=1 AND str_exprres="true") OR (int_fc_success=0 AND str_exprres="false")) { # here a success of 1 follows the "true" path and a success of 0 follows the "false" path
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL str_fc_outcon)
            SETL id_fc_nextelement:(toobjid)
            BREAK
          }
        }
      }
    }

    IF (val_fc_delay > 0 AND id_fc_nextelement<>0) {
      # We use a for loop here so that the execution can also cancel without having to wait the entire time!
      FOR fc_f_iter from:(0) to:(val_fc_delay) {
        CC "AdoScript" SLEEP ms:(100)
        CC "AdoScript" PERCWIN_IS_CANCELED
        IF (canceled=1) {
          SETL id_fc_nextelement:(-1) # Jump out of the while
        }
      }
    } ELSE {
      CC "AdoScript" PERCWIN_IS_CANCELED
      IF (canceled=1) {
          SETL id_fc_nextelement:(-1) # Jump out of the while
      }
    }
  }

  # Doesn't seem to be necessary, since percentage windows seem to be automatically destroyed when the AdoScript execution ends.
  #CC "AdoScript" PERCWIN_DESTROY

  # Load the output into the variable, but only if it's a map
  IF (type(map_fc_outputvars) = "map") {
    SETL str_fc_keys:(try(mapKeysList(map_fc_outputvars), ""))
    FOR str_fc_key in:(str_fc_keys) sep:("~") {
      # We put the values into the output map. Easiest way to do that is using eval.
      SETL map_fc_outputvars[str_fc_key]:(try(eval(map_fc_outputvars[str_fc_key]), undefined))
    }
    # We also load in any of the variables specified to be "returned" unless they're already in the map.
    FOR str_fc_key in:(ids_fc_retvars) sep:("~") {
      IF (type(map_fc_outputvars[str_fc_key]) = "undefined" AND type(try(eval(str_fc_key), undefined)) <> "undefined") {
        SETL map_fc_outputvars[str_fc_key]:(try(eval(str_fc_key), undefined))
      }
      # For debug we also print the returned values if this is the lowest depth
      # Printing for deeper levels is handled in the long WHILE loop by the "higher up" level to not mess up the "(success:...)" message.
      IF (val_fc_execdepth = 1) {
        FC_DEBUG_OUTPUT_INTERNAL ("\n-> returned value for " + str_fc_key + ": " + lam_toString(map_fc_outputvars[str_fc_key])) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      }
    }
    # Also add in any of the "return" variables
  } ELSE { # If it's not a map (whyever) then we set it to an empty map
    SETL map_fc_outputvars:(map())
  }

  # We append two new lines to the output and debug Window in case it is reused in the next execution.
  IF (val_fc_execdepth = 1) {
    FC_STANDARD_OUTPUT_INTERNAL ("\n\n") val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout
    FC_DEBUG_OUTPUT_INTERNAL ("\n\n") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
  }

  # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
  SETG errtext:(str_fc_lasterrtextbeforeexec)
  SETG ecode:(val_fc_lastecodebeforeexec)
}



#------------------------------------------------------------------------------
PROCEDURE global FC_PARESE_OPCODE str_opcode:reference val_fc_output:integer
# Parses the provided code for certain keywords and adapts it where necessary.
# The val_fc_output is necessary to prevent PRINT and PRINTLN to throw an error
# when the output windows aren't available. It has to follow the same style as
# in the FC_EXEC_FC procedure!
# Known keywords:
#  - READ --> read a value from the user and store it in a variable with some
#       type check, trying to use the correct type. Quotation marks entered by
#       the user are escaped to \".
#  - READS --> read a value from the user and store it in a variable as a
#       string. This will always put the input of the user in quotation marks
#       (""). Quotation marks entered by the user are escaped to \".
#  - READN --> read a value from the user and store it in a variable as a
#       number. If it fails to transform the value into an integer or real
#       then ecode will be set to 1.
#  - PRINTLN --> prints the result of the expression in the output window
#       followed by a new-line.
#  - PRINT --> prints the result of the expression in the output window.
#  - INC --> increments the expression.
#  - DEC --> decrements the expression.
#  - := --> assigns the value of the expression on the right to the variable
#       on the left. It is necessary to have a white-space before and after
#       this operation and it must also be the first white-space in the
#       string.
#------------------------------------------------------------------------------
{
  # Replace any code-lines starting with READ
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "READ ", "FC_READ (\"@@@\") any_variable:@@@"))
  # Replace any code-lines starting with READS
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "READS ", "FC_READS (\"@@@\") str_variable:@@@"))
  # Replace any code-lines starting with READN
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "READN ", "FC_READN (\"@@@\") val_variable:@@@"))
  # Replace any code-lines starting with PRINTLN
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "PRINTLN ", "FC_STANDARD_OUTPUT_INTERNAL (lam_toString(@@@) + \"\\n\") val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout"))
  # Replace any code-lines starting with PRINT
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "PRINT ", "FC_STANDARD_OUTPUT_INTERNAL (lam_toString(@@@)) val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout"))
  # Replace any code-lines starting with INC
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "INC ", "SETL @@@:(@@@+1)"))
  # Replace any code-lines starting with DEC
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "DEC ", "SETL @@@:(@@@-1)"))
  # Replace any code-lines which have " := " in the middle (minus the quotes)
  # Note that it uses a special function which checks the left-hand side if it is a valid variable name using a reglar expression
  SETL str_opcode:(fc_replaceAllAssignmentOperations(str_opcode, " := ", "SETL @@l@@:(@@r@@)"))
}



#------------------------------------------------------------------------------
PROCEDURE global FC_STANDARD_OUTPUT_INTERNAL string:str_fc_text val_fc_output:integer str_fc_stdout:reference
# A procedure that writes to the standard output variable and possibly also to
# standard output window.
#------------------------------------------------------------------------------
{
  IF (val_fc_output > 1) {
    CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:(str_fc_text)
  } ELSIF (val_fc_output = 1) { # If it's case 1 then we don't want to overwrite the ecode.
    SETL val_safeecode:(ecode)
    CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:(str_fc_text)
    SETG ecode:(val_safeecode)
  }
  SETL str_fc_stdout:(str_fc_stdout + str_fc_text)
}



#------------------------------------------------------------------------------
PROCEDURE global FC_DEBUG_OUTPUT_INTERNAL string:str_fc_text val_fc_debug:integer str_fc_debout:reference
# A procedure that writes to the debug output variable and possibly also to
# debug output window.
#------------------------------------------------------------------------------
{
  IF (val_fc_debug > 0) {
    # We make sure that debug output never sets an ecode, even if it fails.
    SETL val_safeecode:(ecode)
    CC "AdoScript" OUT winid:(global_str_fc_debugwin) text:(str_fc_text)
    SETG ecode:(val_safeecode)
  }
  SETL str_fc_debout:(str_fc_debout + str_fc_text)
}



#------------------------------------------------------------------------------
PROCEDURE global FC_PRINT string:str_text str_stdout:reference
# Use in the models: FC_PRINT ("string to print") str_stdout:str_fc_stdout
#------------------------------------------------------------------------------
{
  # Check if the output window exists (even though it might not be visible) and print accordingly
  CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:("")
  IF (ecode = 0) {
    FC_STANDARD_OUTPUT_INTERNAL (str_text) val_fc_output:(2) str_fc_stdout:str_stdout
  } ELSE {
    FC_STANDARD_OUTPUT_INTERNAL (str_text) val_fc_output:(0) str_fc_stdout:str_stdout
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_PRINTLN string:str_text str_stdout:reference
# Use in the models: FC_PRINTLN ("string to print") str_stdout:str_fc_stdout
#------------------------------------------------------------------------------
{
  FC_PRINT (str_text + "\n") str_stdout:str_stdout
}



#------------------------------------------------------------------------------
PROCEDURE global FC_READ string:str_locvarname any_variable:reference
# Use in the models: FC_READ ("name_of_variable_to_store_the_value") any_variable:name_of_variable_to_store_the_value
#------------------------------------------------------------------------------
{
  CC "AdoScript" EDITFIELD title:("Enter value") caption:("Enter value for " + str_locvarname)
  IF (ecode = 0) {
    SETL str_fc_userinput:(type(try(VAL text, "string"))) # this variable is necessary to determine the type of what the user entered.
    IF (str_fc_userinput="string" OR str_fc_userinput="undefined") {
      EXECUTE ("SETL any_variable:(\"" + replall(text, "\"", "\\\"")  + "\")") scope:same
    } ELSE {
      EXECUTE ("SETL any_variable:(" + text + ")") scope:same
    }
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_READS string:str_locvarname str_variable:reference
# Use in the models: FC_READS ("name_of_variable_to_store_the_value") str_variable:name_of_variable_to_store_the_value
#------------------------------------------------------------------------------
{
  CC "AdoScript" EDITFIELD title:("Enter value") caption:("Enter value for " + str_locvarname)
  IF (ecode = 0) {
    EXECUTE ("SETL str_variable:(\"" + replall(text, "\"", "\\\"")  + "\")") scope:same
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_READN string:str_locvarname val_variable:reference
# Use in the models: FC_READN ("name_of_variable_to_store_the_value") val_variable:name_of_variable_to_store_the_value
#------------------------------------------------------------------------------
{
  CC "AdoScript" EDITFIELD title:("Enter value") caption:("Enter value for " + str_locvarname)
  IF (ecode = 0) {
    SETL str_fc_userinput:(type(try(VAL text, "string"))) # this variable is necessary to determine the type of what the user entered.
    #IF (search(" integer real ", " " + str_fc_userinput + " ", 0)>=0) { # old approach
    IF (str_fc_userinput = "integer" OR str_fc_userinput = "real") { # If we succeeded in transforming it into a number
      EXECUTE ("SETL val_variable:(" + text + ")") scope:same
    } ELSE { # Otherwise the user input was bad.
      SETG ecode:(1)
    }
  }
}