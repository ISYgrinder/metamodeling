# Version: 1.2.0
# Date: 2022-01-18

# This file contains global procedures to execute Flowcharts.


### Direct Dependencies:
# * ASC_GlobalFunctions_Conversion.asc
# * ASC_GlobalFunctions_MapSupport.asc
# * ASC_GlobalFunctions_StringSupport.asc
# * ASC_GlobalProcedures_ExecAttrProf-beeup.asc
# * ASC_GlobalVariables_FC.asc


# The procedures use the ecode to inform about errors that happen.
# However ecode from CC seems to be "kind of local" unless we make it global.
SETG ecode:(0)
# Same for errtext
SETG errtext:("")



#------------------------------------------------------------------------------
FUNCTION fc_replaceAllOperationShorthandsLineStart:global str_text:string str_keyword:string str_pattern:string
# Replaces every line in str_text starting with str_keyword (and possible
# spaces at the beginning of the line) using the provided str_pattern.
# Use @@@ in the pattern to indicate where everything after str_keyword until
# the end of the line will be inserted. Note that the inserted part is first
# trimmed. str_keyword should not contain the newline character "\n".
#------------------------------------------------------------------------------
return:(
  set(nae, 0),
  while(set(nam, search(str_text, str_keyword, nae))>=0, (
    set(nas, bsearch(str_text, "\n", nam)),
    set(nas, cond(nas<0, 0, nas+1)),
    set(nae, search(str_text, "\n", nam)),
    cond(copy(str_text, nas, nam-nas).trim()="", set(str_text, replaceTextInArea(str_text, nas, nae, replall(str_pattern, "@@@", copy(str_text, nam+(LEN str_keyword), nae-nam-(LEN str_keyword)).trim()))), 0)
  ),
  str_text)
)



#------------------------------------------------------------------------------
FUNCTION fc_replaceAllOperationShorthandsLineMiddle:global str_text:string str_keyword:string str_pattern:string
# Replaces every line in str_text which contains str_keyword somewhere in the
# middle using the provided str_pattern.
# Use @@l@@ in the pattern to indicate where everything before str_keyword and
# @@r@@ where everything after str_keyword should be will be inserted, both
# @@l@@ and @@r@@ will use the content from the str_keywurd until the beginning
# or end of the line. Note that the inserted part is first trimmed. str_keyword
# should not contain the newline character "\n".
#------------------------------------------------------------------------------
return:(
  set(nae, 0),
  while(set(nam, search(str_text, str_keyword, nae))>=0, (
    set(nas, bsearch(str_text, "\n", nam)),
    set(nas, cond(nas<0, 0, nas+1)),
    set(nae, search(str_text, "\n", nam)),
    set(str_text, replaceTextInArea(str_text, nas, nae, replall(replall(str_pattern, "@@r@@", copy(str_text, nam+(LEN str_keyword), nae-nam-(LEN str_keyword)).trim()), "@@l@@", copy(str_text, nas, nam-nas).trim())))
  ),
  str_text)
)



#------------------------------------------------------------------------------
FUNCTION fc_replaceAllAssignmentOperations:global str_text:string str_keyword:string str_pattern:string
# Replaces every line in str_text which contains str_keyword somewhere in the
# middle using the provided str_pattern. Also checks if the part to the left
# is a valid variable name using regular expressions before replacing.
# Use @@l@@ in the pattern to indicate where everything before str_keyword and
# @@r@@ where everything after str_keyword should be will be inserted, both
# @@l@@ and @@r@@ will use the content from the str_keywurd until the beginning
# or end of the line. Note that the inserted part is first trimmed. str_keyword
# should not contain the newline character "\n".
#------------------------------------------------------------------------------
return:(
  set(nae, 0),
  while(set(nam, search(str_text, str_keyword, nae))>=0, (
    set(nas, bsearch(str_text, "\n", nam)),
    set(nas, cond(nas<0, 0, nas+1)),
    set(nae, search(str_text, "\n", nam)),
    set(left, copy(str_text, nas, nam-nas).trim()),
    cond(regex("^([a-zA-Z_])([a-zA-Z0-9_])*(\\[(.)+\\])?$", left), set(str_text, replaceTextInArea(str_text, nas, nae, replall(replall(str_pattern, "@@r@@", copy(str_text, nam+(LEN str_keyword), nae-nam-(LEN str_keyword)).trim()), "@@l@@", left))), 0)
  ),
  str_text)
)



#------------------------------------------------------------------------------
PROCEDURE global FC_EXEC_FC_FROM_START integer:id_start int_userinput:integer map_fc_outputvars:reference str_fc_stdout:reference str_fc_debout:reference
# Executes a Flowchart starting at a Start Terminal. Assumes that the
# operation code and decision expressions are AdoScript. Also uses
# FC_PARESE_OPCODE to allow simplified commands.
# Handles some of the special parts when beginnig at a Start Terminal, like
# checking and asking the user to specify input variable values or reading all
# the execution specific details from the Start Terminal.
#  - id_start - the element where the execution should start.
#  - int_userinput - if true then the Start Terminal will ask the user to
#       provide the input values for the variables, otherwise it will use
#       default values found.
#  - map_fc_outputvars - this is a reference to a map, which is used to return
#       some variables and their values so they can be accessed outside of the
#       scope of this procedure. When passing the map to this procedure the
#       value of each key should hold a variable name (or some simple
#       expression), which will be evaluated at the end of this procedure and
#       its result put into this map under the same key.
#       Note that some expressions might not work because the keys are
#       determined using a custom function. However, if both the key and the
#       value of the passed map are names of variables then everything should
#       work out fine.
#  - str_fc_stdout - any properly written standard output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#  - str_fc_debout - any properly written debug output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#------------------------------------------------------------------------------
{
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_execdelay) as-string
  SETL int_fc_delay:(VAL val)
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_debugconsole) as-string
  IF (val = "yes") { SETL int_fc_debug:(3) } ELSE { SETL int_fc_debug:(-1) }
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_printtimes) as-string
  IF (val = "yes") { SETL int_fc_printtimes:(1) } ELSE { SETL int_fc_printtimes:(0) }
  CC "Core" GET_ATTR_VAL objid:(id_start) attrid:(global_id_fc_highlight) as-string
  IF (val = "yes") { SETL int_fc_highlight:(1) } ELSE { SETL int_fc_highlight:(0) }

  # Ask the user for any required variables that don't have a default value
  SETL map_invars:(map())
  SETL str_invarkeys:("")
  CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_start) attrid:(global_id_fc_reqvars)
  FOR str_rowid in:(rowids) {
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_name) as-string
    SETL str_varname:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_type) as-string
    SETL str_vartype:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_def) as-string
    SETL str_vardef:(val)
    IF (str_vartype = "any" OR str_vartype = "defined") {
      IF (int_userinput) {
        IF (str_vardef = "") {
          SETL str_vardef:("Replace this with the desired value in proper format (i.e. strings should be surrounded by \") for " + str_varname)
        }
        CC "AdoScript" EDITBOX text:(str_vardef) title:("Enter value for " + str_varname)
        IF (endbutton <> "ok") { EXIT }
      }
    } ELSIF (str_vartype = "string" OR str_vartype = "map" OR str_vartype = "array") {
      IF (int_userinput) {
        IF (str_vardef = "") {
          SETL str_vardef:("Replace this with the desired " + str_vartype + " value for " + str_varname)
        }
      }
      IF (str_vartype = "string") {
        IF ((str_vardef SUB 0) = "\"") {
          SETL str_vardef:(copy(str_vardef, 1, -1))
        }
        IF ((str_vardef SUB ((LEN str_vardef)-1)) = "\"") {
          SETL str_vardef:(copy(str_vardef, 0, (LEN str_vardef)-1))
        }
      }
      IF (int_userinput) {
        CC "AdoScript" EDITBOX text:(str_vardef) title:("Enter " + str_vartype + " value for " + str_varname)
        IF (endbutton <> "ok") { EXIT }
      }
    } ELSE {
      IF (int_userinput) {
        CC "AdoScript" EDITFIELD caption:("Enter a value of type " + str_vartype + " for " + str_varname) title:("Enter " + str_vartype + " value for " + str_varname) text:(str_vardef)
        IF (ecode) { EXIT }
      }
    }
    IF (str_vartype = "string") {
      EXECUTE ("SETL map_invars[\"" + str_varname + "\"]:(\"" + text + "\")") scope:same
    } ELSE {
      EXECUTE ("SETL map_invars[\"" + str_varname + "\"]:(" + text + ")") scope:same
    }
    SETL str_invarkeys:(tokcat(str_invarkeys, str_varname, "~"))
  }

  FC_EXEC_FC (id_start) val_fc_delay:(int_fc_delay) val_fc_output:(3) val_fc_debug:(int_fc_debug) val_fc_execdepth:(1) val_fc_printtimes:(int_fc_printtimes) val_fc_highlight:(int_fc_highlight) map_fc_inputvars:(map_invars) str_fc_inputvarskeys:(str_invarkeys) map_fc_outputvars:map_fc_outputvars str_fc_stdout:str_fc_stdout str_fc_debout:str_fc_debout
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX ("Some error occurred while executing the Flowchart:\n" + errtext)
    EXIT
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_EXEC_FC integer:fc_id_startelement val_fc_delay:real val_fc_output:integer val_fc_debug:integer val_fc_execdepth:integer val_fc_printtimes:integer val_fc_highlight:integer map_fc_inputvars:map str_fc_inputvarskeys:string map_fc_outputvars:reference str_fc_stdout:reference str_fc_debout:reference
# Executes a Flowchart starting at a specific element. Assumes that the
# operation code and decision expressions are AdoScript. Also uses
# FC_PARESE_OPCODE to allow simplified commands.
# Additionally it contains some UI stuff as well (pup-up window to cancel
# execution, output window to print to etc.) so it is not just the execution.
#  - fc_id_startelement - the element where the execution should start. Can be
#       something else besides a Start Terminal.
#  - val_fc_delay - number of seconds to wait before executing the next element.
#       Useful to show how the Flowchart is executed. Will be rounded to tenths
#       of a second.
#  - val_fc_output - specifies the standard output behavior. In any case output
#       will be appended to str_fc_stdout. If -1 then the output window will be
#       closed and not used (careful, this can influence other executions!). If
#       0 then the output window will be left alone and output will only be
#       appended to str_fc_stdout. If 1 then it will use the output window
#       should it exist. Note that even if an output window isn't visible it
#       might still exist. If 2 then it will reuse (append to) the available
#       output window or create one if not available. It makes sure that the
#       window is visible. If 3 it will reset the output window or create it if
#       not available and use it.
#       Note: The Standard and Debug output windows are separate!
#  - val_fc_debug - specifies the debug output behavior. In any case debug info
#       will be appended to str_fc_debout. If -1 then the debug window will be
#       closed and not used (careful, this can influence other executions!). If
#       0 then the debug window will be left alone and debug info will only be
#       appended to str_fc_debout. If 1 then it will use the debug window
#       should it exist. Note that even if an debug window isn't visible it
#       might still exist. If 2 then it will reuse (append to) the available
#       debug window or create one if not available. It makes sure that the
#       window is visible. If 3 it will reset the debug window or create it if
#       not available and use it.
#       Note: The Standard and Debug output windows are separate!
#  - val_fc_execdepth - specifies at which depth we are currently executing.
#       Here because we use this procedure recursively.
#  - val_fc_printtimes - if true (1) then any passed Start Terminal and End
#       Terminal will print START/END as well as a timestamp to the output
#       window.
#  - val_fc_highlight - if true (1) then the currently executed element will be
#       shown, selected and highlighted in the model.
#  - map_fc_inputvars - this map is used to pass some variables with their
#       values into the scope of this procedure. They will be set as local
#       variables in this procedure. The keys of the map should specify the
#       name of the variable and the values of the map should be the value for
#       that variable.
#  - str_fc_inputvarskeys - this variable should contain all the valid keys of
#       the map_fc_inputvars map, separated by ~ signs. If it is left empty
#       then the procedure will try to guess all the keys, which can cause
#       problems in some cases (e.g. when a value is also a map).
#  - map_fc_outputvars - this is a reference to a map, which is used to return
#       some variables and their values so they can be accessed outside of the
#       scope of this procedure. When passing the map to this procedure the
#       value of each key should hold a variable name (or some simple
#       expression), which will be evaluated at the end of this procedure and
#       its result put into this map under the same key.
#       Note that some expressions might not work because the keys are
#       determined using a custom function. However, if both the key and the
#       value of the passed map are names of variables then everything should
#       work out fine.
#  - str_fc_stdout - any properly written standard output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#  - str_fc_debout - any properly written debug output (e.g. using PRINT/LN
#       or FC_PRINT/LN) will also be appended to this variable.
#------------------------------------------------------------------------------
{
  #TODO currently "calling" a different flowchart model does not show it in the modeling toolkit. Maybe provide an option to "Open" and jump to any executed "sub-models" instead of just doing them in the background? hmmm maybe if I'd use something like val_fc_highlight to specify the depth and every time we go deeper we -- it, 0 would mean "don't highlight" and -1 would mean "infinite depth.
  #TODO currently there are so many calls to ADOxx Message Ports after an error in the executed code has happened that they overwrite the errtext if an error occurred. Should probably save that errtext so it is available also to the next operation. One example when providing a "string" for READN and the operation that follows the "success = 0") route prints: There was an error entering the variable: CORE_NO_ERROR

  # Make sure that these two are of the proper type.
  IF (type(str_fc_stdout) <> "string") {
    SETL str_fc_stdout:("")
  }
  IF (type(str_fc_debout) <> "string") {
    SETL str_fc_debout:("")
  }
  # We also specify starting values for these two local variables so that we can ignore ecode / errtext in certain parts.
  SETL val_fc_lastecodebeforeexec:(0)
  SETL str_fc_lasterrtextbeforeexec:("")

  # For the case where we don't deal with output windows (val_fc_output or val_fc_debug = 0) we don't have to do anything.
  # In most other cases we close the previous output/debug window.
  IF (val_fc_output < 0 OR val_fc_output > 1) {
    CC "AdoScript" CLOSE_DOCKABLE_WINDOW winid:(global_str_fc_outputwin)
  }
  IF (val_fc_debug < 0 OR val_fc_debug > 1) {
    CC "AdoScript" CLOSE_DOCKABLE_WINDOW winid:(global_str_fc_debugwin)
  }

  # Get and store the model id. It is also used for other things beside the output windows.
  CC "Core" GET_MODEL_ID objid:(fc_id_startelement)
  IF (ecode<>0) {
    SETG errtext:("Encountered an error while trying to read the model information. Stopping script now.")
    EXIT
  }
  SETL id_fc_fcmodelid:(modelid)
  # We also have this variable to be available to the modeler, i.e. a variable that is documented and can be accessed by them.
  SETL this_modelid:(id_fc_fcmodelid)

  # Also remove any previous dyes if there are any in the model
  CC "Modeling" UNDYE_ALL modelid:(id_fc_fcmodelid)

  # The case for reuse or reset of the output/debug window opens them back up.
  # There doesn't seem to be a reliable way of checking if an output window is open (at least I don't know any). Also open <> exist! OUT only fails if the window doesn't exist. Which is the reason why we always close and then reopen it.
  CC "Core" GET_MODEL_INFO modelid:(id_fc_fcmodelid)
  IF (val_fc_output >= 2) {
    CC "AdoScript" CREATE_OUTPUT_WIN winid:(global_str_fc_outputwin) title:(global_str_fc_outputwin + " - " + modelname + " " + ver)
  }
  IF (val_fc_debug >= 2) {
    CC "AdoScript" CREATE_OUTPUT_WIN winid:(global_str_fc_debugwin) title:(global_str_fc_debugwin + " - " + modelname + " " + ver)
  }
  # The case for recreating the output/debug windows also clears them.
  IF (val_fc_output = 3) {
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 1
    CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:("\n")
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 10000
  }
  IF (val_fc_debug = 3) {
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 1
    CC "AdoScript" OUT winid:(global_str_fc_debugwin) text:("\n")
    CC "AdoScript" SET_OUT_MAX_LINE_COUNT 10000
  }

  # We write this debug line because of the way "new lines" are handled later on ... so it doesn't start with an empty line :)
  FC_DEBUG_OUTPUT_INTERNAL ((STR val_fc_execdepth) + ": " + modelname) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout

  # Here we round the provided delay to a value the script can handle: the amount of 100ms sleeps
  SETL val_fc_delay:(round(val_fc_delay*10))

  # Variables used in the execution
  SETL int_fc_success:(0)
  SETL int_fc_conditionfulfilled:(0)
  SETL any_fc_compareval:("")
  SETL id_fc_curelement:(fc_id_startelement)
  #TODO when changing from "single-path" to "multiple-paths" the id_fc_nextelement will have to change to a string, and also probably in name.
  SETL id_fc_nextelement:(fc_id_startelement)
  SETL val_fc_percent:(0)

  # We use the PERCWIN to allow the user to cancel the execution if it takes to long (e.g. infinite loops).
  # Note that this only takes care of infinite loops in the model, not in the executed code itself!
  CC "AdoScript" PERCWIN_CREATE title:"Flowchart execution" with-cancel-button:1

  # Load in the input into this scope
  # If no keys have been specifically provided, then we try to read them out of the map, which can cause problems (e.g. maps in maps)!
  IF (str_fc_inputvarskeys = "") { SETL str_fc_inputvarskeys:(try(mapKeysList(map_fc_inputvars), "")) }
  FOR str_fc_key in:(str_fc_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_fc_inputvars[str_fc_key]) = "string") {
      EXECUTE ("SETL " + str_fc_key + ":(\"" + map_fc_inputvars[str_fc_key] + "\")") scope:same
    } ELSIF (type(map_fc_inputvars[str_fc_key]) <> "undefined") {
      # Special case because empty maps and arrays look the same.
      IF ((type(map_fc_inputvars[str_fc_key]) = "map") AND try(LEN map_fc_inputvars[str_fc_key] = 0, 0)) {
        EXECUTE ("SETL " + str_fc_key + ":(map())") scope:same
      } ELSE {
        EXECUTE ("SETL " + str_fc_key + ":(" + STR map_fc_inputvars[str_fc_key] + ")") scope:same
      }
    }
  }

  # The returned variables can be different depending on where we start, So this variable will hold a list of variable names separated by "~" that should be returned, unless they are already requested through map_fc_outputvars or their value is undefined.
  SETL ids_fc_retvars:("")

  # This executes the elements one after the other, as long as there is a "follow up" element.
  WHILE (id_fc_nextelement>0) {
    IF (val_fc_highlight) {
      # The DYE and UNDYE are useful to show where the execution has ended (e.g. when it ended prematurely). so we have to update it properly.
      CC "Modeling" UNDYE (id_fc_curelement) error-mark
    }
    # Here we can move on to the next element
    # From this point on, until we determine the next element, id_fc_curelement and id_fc_nextelement should have the same value.
    SETL id_fc_curelement:(id_fc_nextelement)
    # We also have this variable to be available to the modeler, i.e. a variable that is documented and can be accessed by them.
    SETL this_objid:(id_fc_curelement)

    # If the "debug window" is used then we print the name of the next element to execute.
    CC "Core" GET_OBJ_NAME objid:(id_fc_curelement)
    FC_DEBUG_OUTPUT_INTERNAL ("\n" + (STR val_fc_execdepth) + ": " + objname) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout

    # Calculate the next percentage for the percentage window and update it.
    SETL val_fc_percent:(val_fc_percent+1)
    IF (val_fc_percent > 100) {
      SETL val_fc_percent:(0)
    }
    CC "AdoScript" PERCWIN_SET percentage:(val_fc_percent) text:("Press the cancel button to stop the execution.")

    # Only jumps to and highlights the elements if so desired.
    IF (val_fc_highlight) {
      # "Find" the element that is to be executed. The benefit of FIND is that it also moves the view to the position of the element.
      # It is also used before the DYE so it doesn't automatically UNDYE the element.
      CC "Modeling" FIND objid:(id_fc_curelement)
      # The DYE and UNDYE are useful to show where the execution has ended (e.g. when it ended prematurely).
      CC "Modeling" DYE (id_fc_curelement) error-mark make-visible
    }

    # Here we start working on the actual execution. It is important that this code is not "out-sourced" in a separate procedure, so the scope of variables set by the EXECUTE remains intact.
    # Otherwise a more complicated approach using maps to pass inputs and outputs is required that unfortunately can cause problems when having maps in maps.
    # All the variables that are set through code in the model are kept in this scope, thus they are available throughout the model.
    CC "Core" GET_CLASS_ID objid:(id_fc_curelement)
    SETL id_fc_curclsid:(classid)

    # Decide how to continue
    IF (id_fc_curclsid = global_id_fc_start) { # For Start Terminal
      CC "Application" GET_DATE_TIME date-format:"dd/mm/yyyy" time-format:"hh:mm:ss"
      IF (val_fc_printtimes) { # If the start/end times are to be printed
        FC_STANDARD_OUTPUT_INTERNAL ("START @ " + (date) + " " + (time) + "\n") val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout
      }
      FC_DEBUG_OUTPUT_INTERNAL (" @ " + (date) + " " + (time)) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      SETG ecode:(0) # We don't mind if failing to write has a problem here.
      # We also check the required variables and handle them accordingly
      CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_reqvars)
      FOR str_rowid in:(rowids) {
        CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_name) as-string
        SETL str_varname:(val)
        CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_type) as-string
        SETL str_vartype:(val)
        IF (type(eval(str_varname)) = "undefined") { # If the variable simply doesn't exist then we set it to the default value
          CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_def) as-string
          IF (val <> "") {
            EXECUTE ("SETL " + str_varname + ":(" + val + ")") scope:same
          }
        }
        SETL str_fc_truevartype:(type(eval(str_varname)))
        # If the variable doesn't fit the specified type then we crash and burn
        IF ((str_fc_truevartype <> str_vartype AND str_vartype <> "any" AND str_vartype <> "defined" AND str_vartype <> "number") OR (str_vartype = "defined" AND str_fc_truevartype = "undefined") OR (str_vartype = "number" AND str_fc_truevartype <> "integer" AND str_fc_truevartype <> "real")) {
          CC "Core" GET_OBJ_NAME objid:(id_fc_curelement)
          FC_DEBUG_OUTPUT_INTERNAL (" failed, because the required variable " + str_varname + " of " + objname + " is of the wrong type. Expected " + str_vartype + " but found " + str_fc_truevartype + ".") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
          SETG ecode:(420)
          SETG errtext:("The required variable " + str_varname + " of " + objname + " is of the wrong type. Expected " + str_vartype + " but found " + str_fc_truevartype + ".")
          EXIT # Here we exit right away since not much has yet happened and we're supposed to fail.
        }
      }
      # And we store any names of variable that should be returned at the end
      CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_retvars)
      FOR str_rowid in:(rowids) {
        CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_reqvar_name) as-string
        SETL ids_fc_retvars:(tokcat(ids_fc_retvars, val, "~"))
      }
      SETL int_fc_success:(1)
      FC_DEBUG_OUTPUT_INTERNAL (" (success: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
    } ELSIF (id_fc_curclsid = global_id_fc_operation) { # For Operation
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_opactive) as-string
      IF (val = "yes") {
        # Get the operation attribute and execute it
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_opcode) as-string
        SETL str_fc_opcode:(val)
        # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
        IF (NOT ecode) {
          SETG errtext:(str_fc_lasterrtextbeforeexec)
          SETG ecode:(val_fc_lastecodebeforeexec)
        }
        # The following procedure is used to find some of the "added keywords" and transforms them into normal AdoScript.
        FC_PARESE_OPCODE str_opcode:str_fc_opcode val_fc_output:(val_fc_output)
        EXECUTE (str_fc_opcode) scope:same
        # Store the ecode / errtext from this execution.
        SETL str_fc_lasterrtextbeforeexec:(errtext)
        SETL val_fc_lastecodebeforeexec:(ecode)
        IF (ecode=0) {
          SETL int_fc_success:(1)
        } ELSE {
          SETL int_fc_success:(0)
        }
        FC_DEBUG_OUTPUT_INTERNAL (" (success: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      } ELSE {
        SETL int_fc_success:(1)
      }
    } ELSIF (id_fc_curclsid = global_id_fc_exoperation) { # For External Operation
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopactive) as-string
      IF (val = "yes") {
        # Check what kind of external operation this is and execute it properly
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exoptype) as-string
        SETL str_fc_exoptype:(val)
        # The next IFs checks which type of functionality is called and then reads the correct configuration parameters and uses the proper procedure.
        IF (str_fc_exoptype = global_str_fc_exoptype_undef) {
          # If it isn't specified then we just don't do anything.
        } ELSIF (str_fc_exoptype = global_str_fc_exoptype_http) {
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
          SETL val_skipprecode:(val)
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
          SETL val_skippostcode:(val)
          CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exophttpcall)
          # Restore the ecode / errtext from the previously executed part before we run any code.
          IF (NOT ecode) {
            SETG errtext:(str_fc_lasterrtextbeforeexec)
            SETG ecode:(val_fc_lastecodebeforeexec)
          }
          # We set empty values for everything that isn't defined of the correct type.
          EXECAP_HTTP_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode)
              str_endpoint:(cond(type(str_call_endpoint) <> "string", "", str_call_endpoint))
              str_method:(cond(type(str_call_method) <> "string", "", str_call_method))
              str_auth:(cond(type(str_call_auth) <> "string", "None", str_call_auth))
              str_username:(cond(type(str_call_username) <> "string", "", str_call_username))
              str_password:(cond(type(str_call_password) <> "string", "", str_call_password))
              map_headers:(cond(type(map_call_headers) <> "map", map(), map_call_headers))
              str_body:(cond(type(str_call_body) <> "string", "", str_call_body))
              val_httpcode:val_http_code
              map_respheaders:map_http_respheaders
              str_respbody:str_http_respbody
          # Store the ecode / errtext from this execution.
          SETL str_fc_lasterrtextbeforeexec:(errtext)
          SETL val_fc_lastecodebeforeexec:(ecode)
        } ELSIF (str_fc_exoptype = global_str_fc_exoptype_oliveop) {
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
          SETL val_skipprecode:(val)
          CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
          SETL val_skippostcode:(val)
          CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopoliveopcall)
          # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
          IF (NOT ecode) {
            SETG errtext:(str_fc_lasterrtextbeforeexec)
            SETG ecode:(val_fc_lastecodebeforeexec)
          }
          # We set empty values for everything that isn't defined of the correct type.
          EXECAP_OLIVE_SERVICE_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode)
              str_endpoint:(cond(type(str_olive_endpoint) <> "string", "", str_olive_endpoint))
              str_microserviceid:(cond(type(str_olive_microserviceid) <> "string", "", str_olive_microserviceid))
              str_microservicename:(cond(type(str_olive_microservicename) <> "string", "", str_olive_microservicename))
              str_operationid:(cond(type(str_olive_operationid) <> "string", "", str_olive_operationid))
              val_usesimpleinput:(cond(type(val_olive_usesimpleinput) <> "integer", -1, val_olive_usesimpleinput))
              map_input:(cond(type(map_olive_input) <> "map", map(), map_olive_input))
              any_serviceresponse:any_olive_result
          # Store the ecode / errtext from this execution.
          SETL str_fc_lasterrtextbeforeexec:(errtext)
          SETL val_fc_lastecodebeforeexec:(ecode)
        } ELSIF (str_fc_exoptype = global_str_fc_exoptype_system OR str_fc_exoptype = global_str_fc_exoptype_model OR str_fc_exoptype = global_str_fc_exoptype_comp OR str_fc_exoptype = global_str_fc_exoptype_asf) { # We merge those together, because they share some similarities, most notably the "Passed Variables" and "Returned Variables".
          # Set up the input map for the "Passed Variables"
          SETL map_call_inputvars:(map())
          SETL str_call_inputvars_keys:("")
          CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_exopinvars)
          FOR str_rowid in:(rowids) {
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_invars_varname) as-string
            SETL str_varname:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_invars_as) as-string
            IF (val <> "") { SETL str_varas:(val) } ELSE { SETL str_varas:(str_varname) }
            SETL map_call_inputvars[str_varas]:(eval(str_varname))
            SETL str_call_inputvars_keys:(tokcat(str_call_inputvars_keys, str_varas, "~"))
          }
          # Set up the output map for the "Returned Variables"
          SETL map_call_outputvars:(map())
          SETL str_call_outputvars_keys:("")
          CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_fc_curelement) attrid:(global_id_fc_exopoutvars)
          FOR str_rowid in:(rowids) {
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_outvars_varname) as-string
            SETL str_varname:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_fc_outvars_as) as-string
            IF (val <> "") { SETL str_varas:(val) } ELSE { SETL str_varas:(str_varname) }
            SETL map_call_outputvars[str_varas]:(str_varname)
            SETL str_call_outputvars_keys:(tokcat(str_call_outputvars_keys, str_varas, "~"))
          }
          # This is where the differences between the various types are processed.
          IF (str_fc_exoptype = global_str_fc_exoptype_system) { # For system calls
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
            SETL val_skipprecode:(val)
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
            SETL val_skippostcode:(val)
            # We set "empty" values for everything that isn't defined of the correct type.
            IF (type(str_command) <> "string") { SETL str_command:("") }
            IF (type(str_commandtype) <> "string") { SETL str_commandtype:("") }
            IF (type(val_showcmd) <> "integer") { SETL val_showcmd:(-1) }
            CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopsyscall)
            # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
            IF (NOT ecode) {
              SETG errtext:(str_fc_lasterrtextbeforeexec)
              SETG ecode:(val_fc_lastecodebeforeexec)
            }
            EXECAP_SYSTEM_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode) str_command:(str_command) str_commandtype:(str_commandtype) val_showcmd:(val_showcmd) map_sys_inputvars:(map_call_inputvars) str_sys_inputvarskeys:(str_call_inputvars_keys) map_sys_outputvars:map_call_outputvars str_sys_output:str_sys_output str_sys_errors:str_sys_errors
            # Store the ecode / errtext from this execution.
            SETL str_fc_lasterrtextbeforeexec:(errtext)
            SETL val_fc_lastecodebeforeexec:(ecode)
          } ELSIF (str_fc_exoptype = global_str_fc_exoptype_asf) { # For calls to AdoScript functionality
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
            SETL val_skipprecode:(val)
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
            SETL val_skippostcode:(val)
            # We set empty values for everything that isn't defined of the correct type.
            IF (type(map_call_filelinks) <> "map") { SETL map_call_filelinks:(map()) }
            CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopasfcall)
            # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
            IF (NOT ecode) {
              SETG errtext:(str_fc_lasterrtextbeforeexec)
              SETG ecode:(val_fc_lastecodebeforeexec)
            }
            EXECAP_ADOSCRIPT_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode) map_asf_filelinks:(map_call_filelinks) map_asf_inputvars:(map_call_inputvars) str_asf_inputvarskeys:(str_call_inputvars_keys) map_asf_outputvars:map_call_outputvars
            # Store the ecode / errtext from this execution.
            SETL str_fc_lasterrtextbeforeexec:(errtext)
            SETL val_fc_lastecodebeforeexec:(ecode)
          } ELSIF (str_fc_exoptype = global_str_fc_exoptype_comp) { # For calls to complex functionality
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepre)
            SETL val_skipprecode:(val)
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopdisablepost)
            SETL val_skippostcode:(val)
            # Here we process the different possible output-window settings
            CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_exopcompoutwins)
            IF (ecode <> 0) {
              IF (type(val_call_output) <> "integer") { SETL val_call_output:(0) }
              IF (type(val_call_debug) <> "integer") { SETL val_call_debug:(0) }
            } ELSIF (val = global_str_fc_exopcompoutwins_ignore) {
              SETL val_call_output:(0)
              SETL val_call_debug:(0)
            } ELSIF (val = global_str_fc_exopcompoutwins_reuseif) {
              SETL val_call_output:(1)
              SETL val_call_debug:(0)
              IF (type(val_fc_debug) = "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(1) } }
            } ELSIF (val = global_str_fc_exopcompoutwins_reusemake) {
              SETL val_call_output:(2)
              SETL val_call_debug:(0)
              IF (type(val_fc_debug) = "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(2) } }
            } ELSIF (val = global_str_fc_exopcompoutwins_reset) {
              SETL val_call_output:(3)
              SETL val_call_debug:(0)
              IF (type(val_fc_debug) = "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(3) } }
            } ELSE {
              IF (type(val_call_output) <> "integer") { SETL val_call_output:(0) }
              IF (type(val_call_debug) <> "integer") { SETL val_call_debug:(0) }
            }
            # We set empty values for everything that isn't defined of the correct type.
            IF (type(val_call_delay) <> "real") { SETL val_call_delay:(0.0) }
            IF (type(id_call_start) <> "integer") { SETL id_call_start:(-1) }
            SETL str_comp_stdout:("")
            SETL str_comp_debout:("")
            CC "Core" GET_REFERENCED_ATTRPROF_VERSION_ID modelid:(id_fc_fcmodelid) objid:(id_fc_curelement) attrid:(global_id_fc_exopcompcall)
            # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
            IF (NOT ecode) {
              SETG errtext:(str_fc_lasterrtextbeforeexec)
              SETG ecode:(val_fc_lastecodebeforeexec)
            }
            EXECAP_COMPLEX_CALL_OVERRIDE (apversionid) val_skipprecode:(val_skipprecode) val_skippostcode:(val_skippostcode) val_comp_execdepth:(val_fc_execdepth+1) id_comp_start:(id_call_start) val_comp_delay:(val_call_delay) val_comp_output:(val_call_output) val_comp_debug:(val_call_debug) map_comp_inputvars:(map_call_inputvars) str_comp_inputvarskeys:(str_call_inputvars_keys) map_comp_outputvars:map_call_outputvars str_comp_stdout:str_comp_stdout str_comp_debout:str_comp_debout
            # Store the ecode / errtext from this execution.
            SETL str_fc_lasterrtextbeforeexec:(errtext)
            SETL val_fc_lastecodebeforeexec:(ecode)
            SETL str_fc_stdout:(str_fc_stdout + str_comp_stdout)
            SETL str_fc_debout:(str_fc_debout + str_comp_debout)
          } ELSIF (str_fc_exoptype = global_str_fc_exoptype_model) { # For referenced models it's a bit different ... hopefully simpler ... NOPE, not simpler.
            # We set values for everything that isn't defined of the correct type, mostly "empty" values.
            IF (type(val_call_delay) <> "real") { SETL val_call_delay:(0.0) }
            IF (type(val_call_output) <> "integer") { IF (val_fc_output > 0) { SETL val_call_output:(1) } ELSE { SETL val_call_output:(0)} }
            IF (type(val_call_debug) <> "integer") { IF (val_fc_debug > 0) { SETL val_call_debug:(1) } ELSE { SETL val_call_debug:(0) } }
            IF (type(val_call_printtimes) <> "integer") { SETL val_call_printtimes:(0) }
            IF (type(val_call_highlight) <> "integer") { SETL val_call_highlight:(0) }
            # Getting the ID of the staring object is a bit more complicated
            CC "Core" GET_INTERREF objid:(id_fc_curelement) attrid:(global_id_fc_exoprefmodstart) index:(0)
            IF (ecode = 0) { # ecode is not 0 for example when there is no reference.
              SETL id_refmod:(tmodelid)
              # We have to load the model if it isn't loaded.
              SETL id_unloadmodel:(-1)
              CC "Core" IS_MODEL_LOADED modelid:(id_refmod)
              IF (NOT isloaded) {
                CC "Core" LOAD_MODEL modelid:(id_refmod)
                IF (ecode = 0) {
                  SETL id_unloadmodel:(id_refmod)
                  CC "Core" GET_INTERREF objid:(id_fc_curelement) attrid:(global_id_fc_exoprefmodstart) index:(0)
                }
              }
              IF (tobjid > -1) {
                # Need to add a new line
                # We could've made it this far only if ecode = 0
                FC_DEBUG_OUTPUT_INTERNAL ("\n") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
                SETL str_mod_stdout:("")
                SETL str_mod_debout:("")
                # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
                IF (NOT ecode) {
                  SETG errtext:(str_fc_lasterrtextbeforeexec)
                  SETG ecode:(val_fc_lastecodebeforeexec)
                }
                FC_EXEC_FC (tobjid) val_fc_delay:(val_call_delay) val_fc_output:(val_call_output) val_fc_debug:(val_call_debug) val_fc_execdepth:(val_fc_execdepth+1) val_fc_printtimes:(val_call_printtimes) val_fc_highlight:(val_call_highlight) map_fc_inputvars:(map_call_inputvars) str_fc_inputvarskeys:(str_call_inputvars_keys) map_fc_outputvars:map_call_outputvars str_fc_stdout:str_mod_stdout str_fc_debout:str_mod_debout
                # Store the ecode / errtext from this execution.
                SETL str_fc_lasterrtextbeforeexec:(errtext)
                SETL val_fc_lastecodebeforeexec:(ecode)
                SETL str_fc_stdout:(str_fc_stdout + str_mod_stdout)
                SETL str_fc_debout:(str_fc_debout + str_mod_debout)
              } ELSE {
                SETG ecode:(420)
              }
              IF (id_unloadmodel > -1) {
                SETL temp_ecode:(ecode) # We want to preserve the ecode after discarding the model
                CC "Core" DISCARD_MODEL modelid:(id_unloadmodel)
                SETG ecode:(temp_ecode)
              }
            }
          }
          IF (ecode = 0) {
            # Process the output map
            #TODO if the variables specified to be "returned" from calling a Flowchart/Start Terminal should be added to the output map, we'd have to get them here out of map_call_outputvars and into this scope.
            FOR str_fc_key in:(str_call_outputvars_keys) sep:("~") {
              SETL str_fc_actualtype:(type(map_call_outputvars[str_fc_key]))
              IF (str_fc_actualtype = "string") {
                EXECUTE ("SETL " + str_fc_key + ":(\"" + map_call_outputvars[str_fc_key] + "\")") scope:same
              } ELSIF (str_fc_actualtype = "undefined") {
                EXECUTE ("SETL " + str_fc_key + ":(undefined)") scope:same
              } ELSE {
                EXECUTE ("SETL " + str_fc_key + ":(" + STR map_call_outputvars[str_fc_key] + ")") scope:same
              }
            }
          }
        } ELSE { # If it is some External Operation we don't know how to handle then we consider it an error
          SETG ecode:(420)
        }
        IF (ecode=0) {
          SETL int_fc_success:(1)
        } ELSE {
          SETL int_fc_success:(0)
        }
        FC_DEBUG_OUTPUT_INTERNAL (" (success: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
        # We also print here the returned values to the debug window
        IF (int_fc_success AND (type(str_call_outputvars_keys) = "string")) {
          FOR str_fc_key in:(str_call_outputvars_keys) sep:("~") {
            FC_DEBUG_OUTPUT_INTERNAL ("\n-> returned value for " + str_fc_key + ": " + eval("lam_toString(" + str_fc_key + ")")) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
          }
        }
      } ELSE { # If the External Operation is not active then we simply follow the success path.
        SETL int_fc_success:(1)
      }
    } ELSIF (id_fc_curclsid = global_id_fc_decision) { # For Decision
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_decactive) as-string
      IF (val = "yes") {
        # Get the check expression attribute and execute it
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_deccode) as-string
        # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
        IF (NOT ecode) {
          SETG errtext:(str_fc_lasterrtextbeforeexec)
          SETG ecode:(val_fc_lastecodebeforeexec)
        }
        EXECUTE ("IF(" + val + ") { SETL int_fc_success:(1) } ELSE { SETL int_fc_success:(0) }") scope:same
      } ELSE {
        SETL int_fc_success:(1)
      }
      FC_DEBUG_OUTPUT_INTERNAL (" (decision: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
    } ELSIF (id_fc_curclsid = global_id_fc_switch) { # For Switch
      # Check if it is active
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_switchactive) as-string
      IF (val = "yes") {
        # Get the check expression attribute and execute it
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_switchcode) as-string
        # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
        IF (NOT ecode) {
          SETG errtext:(str_fc_lasterrtextbeforeexec)
          SETG ecode:(val_fc_lastecodebeforeexec)
        }
        EXECUTE ("SETL any_fc_compareval:(" + val + ")") scope:same
        SETL int_fc_success:(-1)
      } ELSE {
        SETL int_fc_success:(1)
      }
      FC_DEBUG_OUTPUT_INTERNAL (" (switch: " + STR int_fc_success + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
    } ELSIF (id_fc_curclsid = global_id_fc_end) { # For End Terminal
      CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_endingtype)
      SETL str_endingtype:(val)
      CC "Application" GET_DATE_TIME date-format:"dd/mm/yyyy" time-format:"hh:mm:ss"
      IF (val_fc_printtimes) { # If the start/end times are to be printed
        FC_STANDARD_OUTPUT_INTERNAL ("END (" + str_endingtype + ") @ " + (date) + " " + (time)) val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout
      }
      FC_DEBUG_OUTPUT_INTERNAL (" (" + str_endingtype + ") @ " + (date) + " " + (time)) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      IF (str_endingtype = "Success") {
        SETL str_fc_lasterrtextbeforeexec:("")
        SETL val_fc_lastecodebeforeexec:(0)
        SETL int_fc_success:(1)
      } ELSIF (str_endingtype = "Failure") {
        CC "Core" GET_ATTR_VAL objid:(id_fc_curelement) attrid:(global_id_fc_enddescription) as-string
        SETL str_fc_lasterrtextbeforeexec:(cond(ecode, "", val)) # Note that this is the ecode from GET_ATTR_VAL
        SETL val_fc_lastecodebeforeexec:(cond(val_fc_lastecodebeforeexec, val_fc_lastecodebeforeexec, 1))
        SETL int_fc_success:(0)
        FC_DEBUG_OUTPUT_INTERNAL (" - " + errtext) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      } ELSE {
        # Otherwise we don't change anything. Restoring the ecode / errtext has to happen later towards the end of the procedure.
      }
    } ELSE { # For everything else, we don't know what to do with it so we just ... continue
      SETL int_fc_success:(1)
    }

    # Next we try to find the following element
    SETL id_fc_nextelement:(0)
    CC "Core" GET_CONNECTORS objid:(id_fc_curelement) out
    IF (ecode <> 0) {
      FC_DEBUG_OUTPUT_INTERNAL ("\nFailed determining the outgoing connectors of the current element. The execution will be aborted.") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      SETL id_fc_nextelement:(-1) # Jump out of the while
    }
    FOR str_fc_outcon in:(objids) {
      CC "Core" GET_CLASS_ID objid:(VAL str_fc_outcon)
      IF (classid=global_id_fc_subsequent) { # Only consider subsequent relations
        # Check if the condition of the relation is met
        CC "Core" GET_ATTR_VAL objid:(VAL str_fc_outcon) attrid:(global_id_fc_gate) as-string
        SETL str_gate:(val.trim())
        IF (str_gate <> "") {
          EXECUTE ("IF(" + str_gate + ") { SETL int_fc_conditionfulfilled:(1) } ELSE { SETL int_fc_conditionfulfilled:(0) }") scope:same
          IF (NOT int_fc_conditionfulfilled) {
            # If not then skip this relation
            FC_DEBUG_OUTPUT_INTERNAL ("\n\t(subsequent condition failed: " + str_gate + ")") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
            NEXT
          }
        }
        # Here the condition of the relation has been tested and is satisfied, so now we check the other cases.
        CC "Core" GET_ATTR_VAL objid:(VAL str_fc_outcon) attrid:(global_id_fc_expres) as-string
        SETL str_exprres:(val)
        IF (int_fc_success < 0) { # when success < 0 then we have to determine the path through the connectors
          IF (str_exprres="true") {
            CC "Core" GET_ATTR_VAL objid:(VAL str_fc_outcon) attrid:(global_id_fc_compare) as-string
            SETL any_temp:(val)
            IF (any_temp <> "") {
              EXECUTE ("SETL any_temp:(" + val + ")") scope:same
            }
            # Compare if the value from the connector evaluates to the same value as is stored in any_fc_compareval
            IF (type(any_temp) = type(any_fc_compareval)) {
              IF (any_temp = any_fc_compareval) {
                CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL str_fc_outcon)
                SETL id_fc_nextelement:(toobjid)
                BREAK
              }
            }
          } ELSE { # basically we treat the relations with "Exprsesion result" = false as the default paths
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL str_fc_outcon)
            SETL id_fc_nextelement:(toobjid)
            # We don't break, because there might be other relations that actually fulfill the condition!
          }
        } ELSE {
          IF ((int_fc_success=1 AND str_exprres="true") OR (int_fc_success=0 AND str_exprres="false")) { # here a success of 1 follows the "true" path and a success of 0 follows the "false" path
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL str_fc_outcon)
            SETL id_fc_nextelement:(toobjid)
            BREAK
          }
        }
      }
    }

    IF (val_fc_delay > 0 AND id_fc_nextelement<>0) {
      # We use a for loop here so that the execution can also cancel without having to wait the entire time!
      FOR fc_f_iter from:(0) to:(val_fc_delay) {
        CC "AdoScript" SLEEP ms:(100)
        CC "AdoScript" PERCWIN_IS_CANCELED
        IF (canceled=1) {
          SETL id_fc_nextelement:(-1) # Jump out of the while
        }
      }
    } ELSE {
      CC "AdoScript" PERCWIN_IS_CANCELED
      IF (canceled=1) {
          SETL id_fc_nextelement:(-1) # Jump out of the while
      }
    }
  }

  # Doesn't seem to be necessary, since percentage windows seem to be automatically destroyed when the AdoScript execution ends.
  #CC "AdoScript" PERCWIN_DESTROY

  # Load the output into the variable, but only if it's a map
  IF (type(map_fc_outputvars) = "map") {
    SETL str_fc_keys:(try(mapKeysList(map_fc_outputvars), ""))
    FOR str_fc_key in:(str_fc_keys) sep:("~") {
      # We put the values into the output map. Easiest way to do that is using eval.
      SETL map_fc_outputvars[str_fc_key]:(try(eval(map_fc_outputvars[str_fc_key]), undefined))
    }
    # We also load in any of the variables specified to be "returned" unless they're already in the map.
    FOR str_fc_key in:(ids_fc_retvars) sep:("~") {
      IF (type(map_fc_outputvars[str_fc_key]) = "undefined" AND type(try(eval(str_fc_key), undefined)) <> "undefined") {
        SETL map_fc_outputvars[str_fc_key]:(try(eval(str_fc_key), undefined))
      }
      # For debug we also print the returned values if this is the lowest depth
      # Printing for deeper levels is handled in the long WHILE loop by the "higher up" level to not mess up the "(success:...)" message.
      IF (val_fc_execdepth = 1) {
        FC_DEBUG_OUTPUT_INTERNAL ("\n-> returned value for " + str_fc_key + ": " + lam_toString(map_fc_outputvars[str_fc_key])) val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
      }
    }
    # Also add in any of the "return" variables
  } ELSE { # If it's not a map (whyever) then we set it to an empty map
    SETL map_fc_outputvars:(map())
  }

  # We append two new lines to the output and debug Window in case it is reused in the next execution.
  IF (val_fc_execdepth = 1) {
    FC_STANDARD_OUTPUT_INTERNAL ("\n\n") val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout
    FC_DEBUG_OUTPUT_INTERNAL ("\n\n") val_fc_debug:(val_fc_debug) str_fc_debout:str_fc_debout
  }

  # Restore the ecode / errtext from the previously executed part before we run any code, but only of no other error has occured yet.
  SETG errtext:(str_fc_lasterrtextbeforeexec)
  SETG ecode:(val_fc_lastecodebeforeexec)
}



#------------------------------------------------------------------------------
PROCEDURE global FC_PARESE_OPCODE str_opcode:reference val_fc_output:integer
# Parses the provided code for certain keywords and adapts it where necessary.
# The val_fc_output is necessary to prevent PRINT and PRINTLN to throw an error
# when the output windows aren't available. It has to follow the same style as
# in the FC_EXEC_FC procedure!
# Known keywords:
#  - READ --> read a value from the user and store it in a variable with some
#       type check, trying to use the correct type. Quotation marks entered by
#       the user are escaped to \".
#  - READS --> read a value from the user and store it in a variable as a
#       string. This will always put the input of the user in quotation marks
#       (""). Quotation marks entered by the user are escaped to \".
#  - READN --> read a value from the user and store it in a variable as a
#       number. If it fails to transform the value into an integer or real
#       then ecode will be set to 1.
#  - PRINTLN --> prints the result of the expression in the output window
#       followed by a new-line.
#  - PRINT --> prints the result of the expression in the output window.
#  - INC --> increments the expression.
#  - DEC --> decrements the expression.
#  - := --> assigns the value of the expression on the right to the variable
#       on the left. It is necessary to have a white-space before and after
#       this operation and it must also be the first white-space in the
#       string.
#------------------------------------------------------------------------------
{
  # Replace any code-lines starting with READ
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "READ ", "FC_READ (\"@@@\") any_variable:@@@"))
  # Replace any code-lines starting with READS
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "READS ", "FC_READS (\"@@@\") str_variable:@@@"))
  # Replace any code-lines starting with READN
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "READN ", "FC_READN (\"@@@\") val_variable:@@@"))
  # Replace any code-lines starting with PRINTLN
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "PRINTLN ", "FC_STANDARD_OUTPUT_INTERNAL (lam_toString(@@@) + \"\\n\") val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout"))
  # Replace any code-lines starting with PRINT
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "PRINT ", "FC_STANDARD_OUTPUT_INTERNAL (lam_toString(@@@)) val_fc_output:(val_fc_output) str_fc_stdout:str_fc_stdout"))
  # Replace any code-lines starting with INC
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "INC ", "SETL @@@:(@@@+1)"))
  # Replace any code-lines starting with DEC
  SETL str_opcode:(fc_replaceAllOperationShorthandsLineStart(str_opcode, "DEC ", "SETL @@@:(@@@-1)"))
  # Replace any code-lines which have " := " in the middle (minus the quotes)
  # Note that it uses a special function which checks the left-hand side if it is a valid variable name using a reglar expression
  SETL str_opcode:(fc_replaceAllAssignmentOperations(str_opcode, " := ", "SETL @@l@@:(@@r@@)"))
}



#------------------------------------------------------------------------------
PROCEDURE global FC_STANDARD_OUTPUT_INTERNAL string:str_fc_text val_fc_output:integer str_fc_stdout:reference
# A procedure that writes to the standard output variable and possibly also to
# standard output window.
#------------------------------------------------------------------------------
{
  IF (val_fc_output > 1) {
    CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:(str_fc_text)
  } ELSIF (val_fc_output = 1) { # If it's case 1 then we don't want to overwrite the ecode.
    SETL val_safeecode:(ecode)
    CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:(str_fc_text)
    SETG ecode:(val_safeecode)
  }
  SETL str_fc_stdout:(str_fc_stdout + str_fc_text)
}



#------------------------------------------------------------------------------
PROCEDURE global FC_DEBUG_OUTPUT_INTERNAL string:str_fc_text val_fc_debug:integer str_fc_debout:reference
# A procedure that writes to the debug output variable and possibly also to
# debug output window.
#------------------------------------------------------------------------------
{
  IF (val_fc_debug > 0) {
    # We make sure that debug output never sets an ecode, even if it fails.
    SETL val_safeecode:(ecode)
    CC "AdoScript" OUT winid:(global_str_fc_debugwin) text:(str_fc_text)
    SETG ecode:(val_safeecode)
  }
  SETL str_fc_debout:(str_fc_debout + str_fc_text)
}



#------------------------------------------------------------------------------
PROCEDURE global FC_PRINT string:str_text str_stdout:reference
# Use in the models: FC_PRINT ("string to print") str_stdout:str_fc_stdout
#------------------------------------------------------------------------------
{
  # Check if the output window exists (even though it might not be visible) and print accordingly
  CC "AdoScript" OUT winid:(global_str_fc_outputwin) text:("")
  IF (ecode = 0) {
    FC_STANDARD_OUTPUT_INTERNAL (str_text) val_fc_output:(2) str_fc_stdout:str_stdout
  } ELSE {
    FC_STANDARD_OUTPUT_INTERNAL (str_text) val_fc_output:(0) str_fc_stdout:str_stdout
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_PRINTLN string:str_text str_stdout:reference
# Use in the models: FC_PRINTLN ("string to print") str_stdout:str_fc_stdout
#------------------------------------------------------------------------------
{
  FC_PRINT (str_text + "\n") str_stdout:str_stdout
}



#------------------------------------------------------------------------------
PROCEDURE global FC_READ string:str_locvarname any_variable:reference
# Use in the models: FC_READ ("name_of_variable_to_store_the_value") any_variable:name_of_variable_to_store_the_value
#------------------------------------------------------------------------------
{
  CC "AdoScript" EDITFIELD title:("Enter value") caption:("Enter value for " + str_locvarname)
  IF (ecode = 0) {
    SETL str_fc_userinput:(type(try(VAL text, "string"))) # this variable is necessary to determine the type of what the user entered.
    IF (str_fc_userinput="string" OR str_fc_userinput="undefined") {
      EXECUTE ("SETL any_variable:(\"" + replall(text, "\"", "\\\"")  + "\")") scope:same
    } ELSE {
      EXECUTE ("SETL any_variable:(" + text + ")") scope:same
    }
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_READS string:str_locvarname str_variable:reference
# Use in the models: FC_READS ("name_of_variable_to_store_the_value") str_variable:name_of_variable_to_store_the_value
#------------------------------------------------------------------------------
{
  CC "AdoScript" EDITFIELD title:("Enter value") caption:("Enter value for " + str_locvarname)
  IF (ecode = 0) {
    EXECUTE ("SETL str_variable:(\"" + replall(text, "\"", "\\\"")  + "\")") scope:same
  }
}



#------------------------------------------------------------------------------
PROCEDURE global FC_READN string:str_locvarname val_variable:reference
# Use in the models: FC_READN ("name_of_variable_to_store_the_value") val_variable:name_of_variable_to_store_the_value
#------------------------------------------------------------------------------
{
  CC "AdoScript" EDITFIELD title:("Enter value") caption:("Enter value for " + str_locvarname)
  IF (ecode = 0) {
    SETL str_fc_userinput:(type(try(VAL text, "string"))) # this variable is necessary to determine the type of what the user entered.
    #IF (search(" integer real ", " " + str_fc_userinput + " ", 0)>=0) { # old approach
    IF (str_fc_userinput = "integer" OR str_fc_userinput = "real") { # If we succeeded in transforming it into a number
      EXECUTE ("SETL val_variable:(" + text + ")") scope:same
    } ELSE { # Otherwise the user input was bad.
      SETG ecode:(1)
    }
  }
}