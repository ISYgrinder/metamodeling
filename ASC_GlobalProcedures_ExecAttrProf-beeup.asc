# Version: 1.1.0-beeup
# Date: 2022-01-18

# This file contains global variables, functions and procedures to execute
# special attribute profiles representing functionalities similar to add-ons.

##### BEE-UP SPECIFIC START
# This version of the module is adapted for Bee-Up to include attribute
# profiles for the execution of Flowcharts. Easiest way to find the changes is
# to search for "BEE-UP SPECIFIC".
##### BEE-UP SPECIFIC END


### Direct Dependencies:
# * ASC_GlobalFunctions_Conversion.asc
# * ASC_GlobalFunctions_JSON.asc
# * ASC_GlobalFunctions_MapSupport.asc
# * ASC_HttpRequestDll.asc
# * ASC_GlobalProcedures_ExecuteFlowchart.asc - BEE-UP SPECIFIC


# In general the procedures expect an attribute profile object which describes
# how the functionality should be executed. Relevant procedures to use:
# * EXECAP_HTTP_CALL (VAL attrprofids) val_httpcode:dummy map_respheaders:dummy str_respbody:dummy
# * EXECAP_SYSTEM_CALL (VAL attrprofids)
# * EXECAP_ADOSCRIPT_CALL (VAL attrprofids)
# * EXECAP_OLIVE_SERVICE_CALL (VAL attrprofids)
# * EXECAP_COMPLEX_CALL (VAL attrprofids) -> Flowcharts # BEE-UP SPECIFIC


# The procedures use the ecode to inform about errors that happen.
# However ecode from CC seems to be "kind of local" unless we make it global.
SETG ecode:(0)
# Same for errtext
SETG errtext:("")


# Concept names
SETG global_str_execap_genericasf:("AdoScript Functionality (Code)")
SETG global_str_execap_generichttp:("HTTP-called Functionality (Code)")
SETG global_str_execap_genericsys:("System-called Functionality (Code)")
SETG global_str_execap_genericolive:("Call Operation (Olive MSC, Code)")
# Attribute names - AdoScript Functionality
SETG global_str_execap_asf_filelinks:("File links")
SETG global_str_execap_asf_code:("AdoScript code")
SETG global_str_execap_genasf_preproc:("Pre-processing")
SETG global_str_execap_genasf_postproc:("Post-processing")
# Attribute names - HTTP-called Functionality
SETG global_str_execap_http_endpoint:("Endpoint")
SETG global_str_execap_http_method:("Method")
SETG global_str_execap_http_auth:("Authentication")
SETG global_str_execap_http_uname:("Username")
SETG global_str_execap_http_passwd:("Password")
SETG global_str_execap_genhttp_preproc:("Pre-processing")
SETG global_str_execap_genhttp_postproc:("Post-processing")
# Attribute names - System-called Functionality
SETG global_str_execap_sys_cmd:("Command")
SETG global_str_execap_sys_args:("Arguments")
SETG global_str_execap_sys_showcmd:("Show console")
SETG global_str_execap_gensys_preproc:("Pre-processing")
SETG global_str_execap_gensys_postproc:("Post-processing")
# Attribute names - Call Operation (Olive)
SETG global_str_execap_olive_endpoint:("Endpoint")
SETG global_str_execap_olive_microserviceid:("Microservice ID")
SETG global_str_execap_olive_microservicename:("Microservice name")
SETG global_str_execap_olive_operationid:("Operation ID")
SETG global_str_execap_olive_simpleinput:("Use simple input map")
SETG global_str_execap_olive_inputparameters:("Input parameters")
SETG global_str_execap_olive_preproc:("Pre-processing")
SETG global_str_execap_olive_postproc:("Post-processing")
# Attribute names - Arguments
SETG global_str_execap_argsprefconst:("Prefix / Constant")
SETG global_str_execap_argsvarval:("Variable value")
# Attribute names - File links
SETG global_str_execap_flid:("ID")
SETG global_str_execap_flpath:("File")
# Attribute names - Input parameters
SETG global_str_execap_inname:("Input name")
SETG global_str_execap_indefault:("Default value")

# Constant values
SETG global_str_execap_sys_cmd_synchcmd:("Synchronous CMD")
SETG global_str_execap_sys_cmd_asynchcmd:("Asynchronous CMD")
SETG global_str_execap_sys_cmd_app:("Application")

# Concept IDs
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericasf)
SETG global_id_execap_genericasf:(apclassid)
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_generichttp)
SETG global_id_execap_generichttp:(apclassid)
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericsys)
SETG global_id_execap_genericsys:(apclassid)
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericolive)
SETG global_id_execap_genericolive:(apclassid)

# Record IDs
CC "Core" GET_ATTR_ID classid:(global_id_execap_genericasf) attrname:(global_str_execap_asf_filelinks)
SETG global_id_execap_asf_filelinks:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_execap_genericsys) attrname:(global_str_execap_sys_args)
SETG global_id_execap_sys_args:(attrid)
CC "Core" GET_ATTR_ID classid:(global_id_execap_genericolive) attrname:(global_str_execap_olive_inputparameters)
SETG global_id_execap_olive_inputparameters:(attrid)


##### BEE-UP SPECIFIC START
# Concept names
SETG global_str_execap_genericcomp:("Complex Functionality (Code)")
# Attribute names - Complex Functionality
SETG global_str_execap_comp_refstart:("Described through")
SETG global_str_execap_comp_reqvars:("Required variables")
SETG global_str_execap_comp_retvars:("Returned variables")
SETG global_str_execap_gencomp_preproc:("Pre-processing")
SETG global_str_execap_gencomp_postproc:("Post-processing")
# Concept IDs
CC "Core" GET_ATTRPROFCLASS_ID apclassname:(global_str_execap_genericcomp)
SETG global_id_execap_genericcomp:(apclassid)
##### BEE-UP SPECIFIC END



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_EXECUTE_ATTRPROF_GUI
# This procedure allows the user to select an Attribute Profile describing a
# functionality and execute it.
#------------------------------------------------------------------------------
{
  # Select which service call to execute
  # BEE-UP SPECIFIC adds to the filter.
  CC "CoreUI" ATTRPROF_SELECT_BOX with-mgmt-functions filter:(STR global_id_execap_generichttp + " " + STR global_id_execap_genericsys + " " + STR global_id_execap_genericcomp + " " + STR global_id_execap_genericasf + " " + STR global_id_execap_genericolive) title:("Execute external functionality") boxtext:("Select which external functionality should be executed.") oktext:("Execute")
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX ("Some error occurred while selecting the functionality:\n" + errtext)
    EXIT
  } ELSIF (endbutton <> "ok") {
    EXIT
  }

  EXECAP_EXECUTE_ATTRPROF (VAL attrprofids)

  # If something went wrong then show the user the error.
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX ("Some error occurred while trying to call the external functionality:\n" + errtext)
    EXIT
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_EXECUTE_ATTRPROF integer:id_functionobj
# This procedure allows the user to select an Attribute Profile describing a
# functionality and execute it.
#------------------------------------------------------------------------------
{
  # Check which procedure has to be called based on the type
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  SETL id_selcid:(apclassid)
  IF (id_selcid = global_id_execap_genericasf) {
    EXECAP_ADOSCRIPT_CALL (id_functionobj)
  } ELSIF (id_selcid = global_id_execap_generichttp) {
    EXECAP_HTTP_CALL (id_functionobj) val_httpcode:dummy map_respheaders:dummy str_respbody:dummy
  } ELSIF (id_selcid = global_id_execap_genericsys) {
    EXECAP_SYSTEM_CALL (id_functionobj)
  } ELSIF (id_selcid = global_id_execap_genericolive) {
    EXECAP_OLIVE_SERVICE_CALL (id_functionobj)
  }
  ##### BEE-UP SPECIFIC START
  ELSIF (id_selcid = global_id_execap_genericcomp) {
    EXECAP_COMPLEX_CALL (id_functionobj)
  }
  ##### BEE-UP SPECIFIC END
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_ADOSCRIPT_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer map_asf_filelinks:map map_asf_inputvars:map str_asf_inputvarskeys:string map_asf_outputvars:reference
# This procedure allows to execute an External Functionality described through
# a "AdoScript Functionality" Attribute Profile and provides the result.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericasf) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericasf)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genasf_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genasf_postproc)
    SETL str_postcallcode:(val)
  }

  # Load in the input
  # If no keys have been specifically provided, then we try to read them out of the map, which can cause problems (e.g. maps in maps)!
  IF (str_asf_inputvarskeys = "") { SETL str_asf_inputvarskeys:(mapKeysList(map_asf_inputvars)) }
  FOR str_asf_key in:(str_asf_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_asf_inputvars[str_asf_key]) = "string") {
      EXECUTE ("SETL " + str_asf_key + ":(\"" + map_asf_inputvars[str_asf_key] + "\")") scope:same
    } ELSIF (type(map_asf_inputvars[str_asf_key]) <> "undefined") {
      EXECUTE ("SETL " + str_asf_key + ":(" + STR map_asf_inputvars[str_asf_key] + ")") scope:same
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Load the linked files into the map unless they're already in there
  # Since we're not the ones doing anything with those files we also just provide their path as is.
  # This works because GET_ALL_REC_ATTR_ROW_IDS seems to return the rows in their correct order.
  CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_functionobj) attrid:(global_id_execap_asf_filelinks)
  FOR str_rowid in:(rowids) {
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_flid) as-string
    SETL str_fileid:(val)
    IF (type(map_asf_filelinks[str_fileid]) = "undefined") {
      CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_flpath) as-string
      SETL str_filepath:(eval(copy(val, search(val, "param:", 0)+6, -1)))
      SETL map_asf_filelinks[str_fileid]:(str_filepath)
    }
  }

  # Execute the specified code
  SETL str_adoscriptcode:("")
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_asf_code)
  SETL str_adoscriptcode:(val)
  IF (str_adoscriptcode <> "") {
    EXECUTE (str_adoscriptcode) scope:same
  }

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }

  # Load the output into the variable, but only if it's a map
  IF (type(map_asf_outputvars) = "map") {
    SETL str_asf_keys:(mapKeysList(map_asf_outputvars))
    FOR str_asf_key in:(str_asf_keys) sep:("~") {
      # We put the values into the output map. Easiest way to do that is using eval.
      SETL map_asf_outputvars[str_asf_key]:(eval(map_asf_outputvars[str_asf_key]))
    }
  } ELSE { # If it's not a map (whyever) then we set it to an empty map
    SETL map_asf_outputvars:(map())
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_ADOSCRIPT_CALL integer:id_functionobj
# This procedure allows to execute an External Functionality described through
# an "AdoScript Functionality" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_ADOSCRIPT_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL temp_emptymap:(map())
  EXECAP_ADOSCRIPT_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) map_asf_filelinks:(map()) map_asf_inputvars:(map()) str_asf_inputvarskeys:("") map_asf_outputvars:temp_emptymap
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_HTTP_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer str_endpoint:string str_method:string str_auth:string str_username:string str_password:string map_headers:map str_body:string val_httpcode:reference map_respheaders:reference str_respbody:reference
# This procedure allows to execute an External Functionality described through
# an "HTTP-called Functionality" Attribute Profile and provides the result of
# the HTTP call.
# Currently only normal HTTP calls (with or without basic authentication) are
# possible.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#  - id_functionobj - the id of the attribute profile describing the called
#       functionality.
#  - val_skipprecode - if true (1) the pre-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - val_skippostcode - if true (1) the post-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - str_endpoint - allows to override the used endpoint. Leave empty ("") to
#       use the endpoint specified in the referenced attribute profile. If the
#       endpoint provided through the parameter starts with an "@" then it will
#       be appended in addition to the endpoint provided in the attribute
#       profile (minus the @).
#  - str_method - allows to override the used method. Leave empty ("") to use
#       the method specified in the referenced attribute profile.
#  - str_auth - allows to override the used authentication. Leave empty ("") to
#       use the authentication mode specified in the referenced attribute
#       profile. Currently only "Basic" and "None" are supported.
#  - str_username - allows to override the used username during authentication.
#       Leave empty ("") to use the username specified in the referenced
#       attribute profile.
#  - str_password - allows to override the used password during authentication.
#       Leave empty ("") to use the password specified in the referenced
#       attribute profile.
#  - map_headers - specifies which headers should be used in the HTTP call.
#       Both keys and values should be of type string.
#       Note that those can be overwritten by the pre-processing code if not
#       disabled.
#  - str_body - specifies the body that is sent in the HTTP call.
#       Note that those can be overwritten by the pre-processing code if not
#       disabled.
#  - val_httpcode - a reference that will contain the returned status code
#       of the HTTP call as an integer.
#  - map_respheaders - a reference that will contain the headers of the
#       response as a map. Both keys and values are strings.
#  - str_respbody - a reference that will contain the body/content of the
#       response as a string. Since the HTTP-call uses NUL terminated strings
#       (\0) the response can be cut short in some cases (e.g. byte data).
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_generichttp) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_generichttp)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # We also have a small "hack" where an endpoint starting with @ (which shouldn't be?) will replace the @ with the endpoint specified in the attribute profile
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (str_endpoint = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_endpoint)
    SETL str_endpoint:(val)
  } ELSIF ((str_endpoint SUB 0) = "@") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_endpoint)
    SETL str_endpoint:(replace(str_endpoint, "@", val))
  }
  IF (str_method = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_method)
    SETL str_method:(val)
  }
  IF (str_auth = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_auth)
    SETL str_auth:(val)
  }
  IF (str_username = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_uname)
    SETL str_username:(val)
  }
  IF (str_password = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_http_passwd)
    SETL str_password:(val)
  }
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")

  # For the "Generic" HTTP call we use the code provided as is (unless we're supposed to skip it)
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genhttp_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_genhttp_postproc)
    SETL str_postcallcode:(val)
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Since calling services can take quite some time we show the Message Window
  CC "AdoScript" MSGWIN ("Calling service ...")

  # Perform the HTTP call
  #TODO the HttpRequest thing actually has many more options ... extend this to also include them.
  IF (str_auth = "Basic") {
    HTTP_SEND_AUTH_REQUEST (str_endpoint) str_method:(str_method) str_username:(str_username) str_password:(str_password) map_reqheaders:(map_headers) str_reqbody:(str_body) val_respcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
  } ELSE {
    HTTP_SEND_REQUEST (str_endpoint) str_method:(str_method) map_reqheaders:(map_headers) str_reqbody:(str_body) val_respcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
  }
  CC "AdoScript" MSGWIN hide

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }
}

#------------------------------------------------------------------------------
PROCEDURE global EXECAP_HTTP_CALL integer:id_functionobj val_httpcode:reference map_respheaders:reference str_respbody:reference
# This procedure allows to quickly execute an External Functionality described
# through an "HTTP-called Functionality" Attribute Profile and provides the
# result of the HTTP call.
# Currently only normal HTTP calls (with or without basic authentication) are
# possible.
# For more control over certain aspects use EXECAP_HTTP_CALL_OVERRIDE.
#  - id_functionobj - the id of the attribute profile describing the called
#       functionality.
#  - val_httpcode - a reference that will contain the returned status code
#       of the HTTP call as an integer.
#  - map_respheaders - a reference that will contain the headers of the
#       response as a map. Both keys and values are strings.
#  - str_respbody - a reference that will contain the body/content of the
#       response as a string. Since the HTTP-call uses NUL terminated strings
#       (\0) the response can be cut short in some cases (e.g. byte data)
#------------------------------------------------------------------------------
{
  EXECAP_HTTP_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) str_endpoint:("") str_method:("") str_auth:("") str_username:("") str_password:("") map_headers:(map()) str_body:("") val_httpcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_SYSTEM_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer str_command:string str_commandtype:string val_showcmd:integer map_sys_inputvars:map str_sys_inputvarskeys:string map_sys_outputvars:reference str_sys_output:reference str_sys_errors:reference
# This procedure allows to execute an External Functionality described through
# a "System-called Functionality" Attribute Profile and provides the result.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#  - map_sys_outputvars - should be a map where the keys specify the variables
#       that are wanted and the value in their map should specify an expression
#       how to get their value (e.g. a variable name, but more complex things
#       might also be possible).
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericsys) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericsys)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (str_command = "" OR str_commandtype = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_sys_cmd)
    SETL str_cmdpar:(val)
    IF (str_command = "") {
      SETL val_fq:(search(str_cmdpar, "param:\"", 0)+7)
      SETL str_command:(copy(str_cmdpar, val_fq, (LEN str_cmdpar)-val_fq-1))
    }
    IF (str_commandtype = "") {
      SETL val_fq:(search(str_cmdpar, "\"", 0)+1)
      SETL str_commandtype:(copy(str_cmdpar, val_fq, search(str_cmdpar, "\"", val_fq)-val_fq))
    }
  }
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gensys_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gensys_postproc)
    SETL str_postcallcode:(val)
  }

  # Load in the input
  # If no keys have been specifically provided, then we try to read them out of the map!
  IF (str_sys_inputvarskeys = "") { SETL str_sys_inputvarskeys:(mapKeysList(map_sys_inputvars)) }
  FOR str_sys_key in:(str_sys_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_sys_inputvars[str_sys_key]) = "string") {
      EXECUTE ("SETL " + str_sys_key + ":(\"" + map_sys_inputvars[str_sys_key] + "\")") scope:same
    } ELSIF (type(map_sys_inputvars[str_sys_key]) <> "undefined") {
      EXECUTE ("SETL " + str_sys_key + ":(" + STR map_sys_inputvars[str_sys_key] + ")") scope:same
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Now we process the Arguments table
  SETL str_sys_args:("")
  CC "Core" GET_REC_ATTR_ROW_COUNT objid:(id_functionobj) attrid:(global_id_execap_sys_args)
  SETL val_sys_argscount:(count)
  FOR i from:1 to:(val_sys_argscount) {
    CC "Core" GET_REC_ATTR_ROW_ID objid:(id_functionobj) attrid:(global_id_execap_sys_args) index:(i)
    CC "Core" GET_ATTR_VAL objid:(rowid) attrname:(global_str_execap_argsprefconst) as-string
    IF (ecode = 0 AND val <> "") {
      SETL str_sys_args:(str_sys_args + " " + val)
    }
    CC "Core" GET_ATTR_VAL objid:(rowid) attrname:(global_str_execap_argsvarval) as-string
    IF (ecode = 0 AND val <> "") {
      EXECUTE ("SETL str_sys_args:(str_sys_args + \" \" + lam_toString(" + val + "))") scope:same
    }
  }

  # We only execute if there is a command or at least arguments (maybe someone had the "good" idea of putting the command in through arguments?
  IF (str_command <> "" OR str_sys_args <> "") {
    # Depending on what type of execution this is we handle it differently.
    # "Synchronous CMD", "Asynchronous CMD", "Application"
    IF (str_commandtype = global_str_execap_sys_cmd_synchcmd OR str_commandtype = global_str_execap_sys_cmd_asynchcmd) {
      IF (val_showcmd < 0) {
        CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_sys_showcmd)
        SETL val_showcmd:(val)
      }
      # We get two file names to store the result of the cmd call in them
      CC "AdoScript" GET_TEMP_FILENAME
      SETL str_sys_outputfile:(filename)
      CC "AdoScript" GET_TEMP_FILENAME
      SETL str_sys_errorfile:(filename)
      # In Synchronous cases we use SYSTEM and read the file results directly
      IF (str_commandtype = global_str_execap_sys_cmd_synchcmd) {
        IF (val_showcmd) { # The eval(...) is necessary to properly interpret any escape characters in ADOxx (e.g. \\ --> \)
          SYSTEM ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile) with-console-window
        } ELSE {
          SYSTEM ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile)
        }
        CC "AdoScript" FREAD file:(str_sys_outputfile)
        SETL str_sys_output:(text)
        CC "AdoScript" DELETE_FILES (str_sys_outputfile)
        CC "AdoScript" FREAD file:(str_sys_errorfile)
        SETL str_sys_errors:(text)
        CC "AdoScript" DELETE_FILES (str_sys_errorfile)
      } ELSE { # Otherwise it's asynchronous in which case we use START and return the file names
        IF (val_showcmd) { # The eval(...) is necessary to properly interpret any escape characters in ADOxx (e.g. \\ --> \)
          START ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile) cmdshow:shownormal
        } ELSE {
          START ("cmd /c (" + eval("\"" + str_command + "\"") + str_sys_args + ") > " + str_sys_outputfile + " 2> " + str_sys_errorfile) cmdshow:showminnoactive
        }
        SETL str_sys_output:(str_sys_outputfile)
        SETL str_sys_errors:(str_sys_errorfile)
      }
    } ELSIF (str_commandtype = global_str_execap_sys_cmd_app) {
      START (eval("\"" + str_command + "\"") + str_sys_args) cmdshow:shownormal
      # I don't know of any way to communicate reliably with an Application other than cmd soooooo we just leave the two empty
      SETL str_sys_output:("")
      SETL str_sys_errors:("")
    }
  }

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }

  # Load the output into the variable, but only if it's a map
  IF (type(map_sys_outputvars) = "map") {
    SETL str_sys_keys:(mapKeysList(map_sys_outputvars))
    FOR str_sys_key in:(str_sys_keys) sep:("~") {
      # We put the values into the output map. Easiest way to do that is using eval.
      SETL map_sys_outputvars[str_sys_key]:(try(eval(map_sys_outputvars[str_sys_key]), undefined))
    }
  } ELSE { # If it's not a map (whyever) then we set it to an empty map
    SETL map_sys_outputvars:(map())
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_SYSTEM_CALL integer:id_functionobj
# This procedure allows to execute an External Functionality described through
# a "System-called Functionality" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_SYSTEM_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL temp_emptymap:(map())
  EXECAP_SYSTEM_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) str_command:("") str_commandtype:("") val_showcmd:(-1) map_sys_inputvars:(temp_emptymap) str_sys_inputvarskeys:("") map_sys_outputvars:temp_emptymap str_sys_output:dummy str_sys_errors:dummy
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_OLIVE_SERVICE_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer str_endpoint:string str_microserviceid:string str_microservicename:string str_operationid:string val_usesimpleinput:integer map_input:map any_serviceresponse:reference
# This procedure allows to execute an External Functionality described through
# an "Call Operation (Olive)" Attribute Profile and provides the result.
# Currently only normal HTTP calls (with or without basic authentication) are
# possible.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#  - id_functionobj - the id of the attribute profile describing the called
#       functionality.
#  - val_skipprecode - if true (1) the pre-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - val_skippostcode - if true (1) the post-processing code specified in the
#       attribute profile will not be executed (i.e. skipped).
#  - str_endpoint - allows to override the used endpoint. Leave empty ("") to
#       use the endpoint specified in the referenced attribute profile. If the
#       endpoint provided through the parameter starts with an "@" then it will
#       be appended in addition to the endpoint provided in the attribute
#       profile (minus the @).
#  - str_microserviceid - allows to override the used microservice ID. Leave
#       empty ("") to use the ID specified in the referenced attribute profile.
#       Typically a UUID (often without the {}), but other values are possible.
#  - str_microservicename - allows to override the used microservice name.
#       Leave empty ("") to use the name specified in the referenced attribute
#       profile. The name is only used when no Microservice ID has been found.
#  - str_operationid - allows to override the used operation ID. Leave empty
#       ("") to use the ID specified in the referenced attribute profle. Often
#       the operation ID is the same as its name.
#  - val_usesimpleinput - allows to override the style of input map to use. Use
#       a negative number to use the value specified in the referenced
#       attribute profile. See further below for more details
#  - map_input - allows to specify a map with the input values to use. Note
#       that any default values specified in the "Input parameters" of the
#       referenced attribute profile are added to the map IF their names are
#       not yet located in the map (i.e. the name as key is undefined).
#  - any_serviceresponse - a reference that will contain the result from
#       calling the service using the best fitting datatype. In case the
#       service has failed it can contain some error information.
#
# Input simplified structure:
# {
#   "gitlab_url": "http://192.168.0.42:8080",
#   "gitlab_project_id": 162
# }
# Input structure expected by Olive MSC:
# {
#   "gitlab_url": {
#     "value": "http://192.168.0.42:8080"
#   },
#   "gitlab_project_id": {
#     "value": "162"
#   }
# }
# Note that in both cases the map has to be simple, i.e. the values should not
# be arrays or maps. This is due to the interface the Olive MSC provides. If
# necessary transform complex values to JSON strings using the mapToJson(myMap)
# or arrayToJson(myArray) functions.
#
# Sets ecode for errors. If it failed due to an HTTP status code then it will
# have that status code.
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericolive) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericolive)
    EXIT
  }

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases.
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (str_endpoint = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_endpoint)
    SETL str_endpoint:(val)
  } ELSIF ((str_endpoint SUB 0) = "@") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_endpoint)
    SETL str_endpoint:(replace(str_endpoint, "@", val))
  }
  IF (str_microserviceid = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_microserviceid)
    SETL str_microserviceid:(val)
  }
  IF (str_microservicename = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_microservicename)
    SETL str_microservicename:(val)
  }
  IF (str_operationid = "") {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_operationid)
    SETL str_operationid:(val)
  }
  IF (val_usesimpleinput < 0) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_simpleinput)
    SETL val_usesimpleinput:(val)
  }
  # Making sure that those two have a value.
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_olive_postproc)
    SETL str_postcallcode:(val)
  }

  # Add to the map_input all the default values if they aren't alreay present.
  CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(id_functionobj) attrid:(global_id_execap_olive_inputparameters)
  FOR str_rowid in:(rowids) {
    CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_inname) as-string
    SETL str_inparmname:(val)
    IF (type(map_input[str_inparmname]) = "undefined") {
      CC "Core" GET_ATTR_VAL objid:(VAL str_rowid) attrname:(global_str_execap_indefault) as-string
      IF (val_usesimpleinput) {
        SETL map_input[str_inparmname]:(eval(val))
      } ELSE {
        SETL map_input[str_inparmname]:({"value": lam_toString(eval(val))})
      }
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # Since calling services can take quite some time we show the Message Window
  CC "AdoScript" MSGWIN ("Calling service ...")

  # Call the Service available through the Olive MSC
  SETG ecode:(0)
  IF (str_microserviceid = "") {
    OLIVE_MSC_GET_MICROSERVICE_ID mscRestUrl:(str_endpoint) microserviceName:(str_microservicename) microserviceId:str_microserviceid
  }
  IF (NOT ecode) {
    # Transform the map_input into the correct JSON string.
    IF (val_usesimpleinput) {
      SETL str_inputstring:(mapToOliveJson(map_input))
    } ELSE {
      SETL str_inputstring:(mapToJson(map_input))
    }
    OLIVE_MSC_CALL_MICROSERVICE_ID_OPERATION mscRestUrl:(str_endpoint) microserviceId:(str_microserviceid) operationId:(str_operationid) input:(str_inputstring) response:any_serviceresponse
  }

  CC "AdoScript" MSGWIN hide

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_OLIVE_SERVICE_CALL integer:id_functionobj any_serviceresponse:reference
# This procedure allows to execute an External Functionality described through
# a "Call Operation (Olive)" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_OLIVE_SERVICE_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL str_dummyresult:("")
  EXECAP_OLIVE_SERVICE_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) str_endpoint:("") str_microserviceid:("") str_microservicename:("") str_operationid:("") val_usesimpleinput:(-1) map_input:(map()) any_serviceresponse:any_serviceresponse
}



##### BEE-UP SPECIFIC START

#------------------------------------------------------------------------------
PROCEDURE global EXECAP_COMPLEX_CALL_OVERRIDE integer:id_functionobj val_skipprecode:integer val_skippostcode:integer val_comp_execdepth:integer id_comp_start:integer val_comp_delay:real val_comp_output:integer val_comp_debug:integer map_comp_inputvars:map str_comp_inputvarskeys:string map_comp_outputvars:reference str_comp_stdout:reference str_comp_debout:reference
# This procedure allows to execute an External Functionality described through
# a "Complex Functionality" Attribute Profile and provides the result.
# It also allows to override certain values to be used instead of the ones
# specified in the Attribute Profiles.
#------------------------------------------------------------------------------
{
  # Check if the passed id is actually an Attribute Profile that describes a service
  CC "Core" GET_ATTRPROF_CLASS_OF_VERSION apversionid:(id_functionobj)
  IF (ecode <> 0) {
    SETG errtext:("The provided ID " + STR id_functionobj + " doesn't seem to be for an Attribute Profile.")
    EXIT
  }
  SETL cid_functionobj:(apclassid)
  IF (cid_functionobj <> global_id_execap_genericcomp) {
    SETG ecode:(420)
    SETG errtext:("The type of the provided Attribute Profile with ID " + STR id_functionobj + " is not supported by this procedure. Supported types:\n" + global_str_execap_genericcomp)
    EXIT
  }
  # We might have to load some model if it isn't loaded.
  SETL id_unloadmodel:(-1)

  # Load the attributes from the Attribute Profile and/or set some default values for the different cases
  # No need to check for type, because those are parameters from the procedure, so a wrong type already fails when calling the procedure.
  IF (id_comp_start <= 0) {
    # Getting the ID of the staring object is a bit more complicated
    CC "Core" GET_INTERREF objid:(id_functionobj) attrname:(global_str_execap_comp_refstart) index:(0)
    IF (ecode = 0) { # ecode is not 0 for example when there is no reference.
      SETL id_refmod:(tmodelid)
      CC "Core" IS_MODEL_LOADED modelid:(id_refmod)
      IF (NOT isloaded) {
        CC "Core" LOAD_MODEL modelid:(id_refmod)
        IF (ecode = 0) {
          SETL id_unloadmodel:(id_refmod)
          CC "Core" GET_INTERREF objid:(id_functionobj) attrname:(global_str_execap_comp_refstart) index:(0)
        }
      }
      SETL id_comp_start:(tobjid)
    }
  }
  # Making sure that those two have a value
  SETL str_precallcode:("")
  SETL str_postcallcode:("")
  IF (NOT val_skipprecode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gencomp_preproc)
    SETL str_precallcode:(val)
  }
  IF (NOT val_skippostcode) {
    CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_gencomp_postproc)
    SETL str_postcallcode:(val)
  }

  # Load in the input
  # If no keys have been specifically provided, then we try to read them out of the map, which can cause problems (e.g. maps in maps)!
  IF (str_comp_inputvarskeys = "") { SETL str_comp_inputvarskeys:(mapKeysList(map_comp_inputvars)) }
  FOR str_comp_key in:(str_comp_inputvarskeys) sep:("~") {
    # We bring the input into the same scope. We also allow it to rewrite some of the other variables if they share the same name.
    IF (type(map_comp_inputvars[str_comp_key]) = "string") {
      EXECUTE ("SETL " + str_comp_key + ":(\"" + map_comp_inputvars[str_comp_key] + "\")") scope:same
    } ELSIF (type(map_comp_inputvars[str_comp_key]) <> "undefined") {
      EXECUTE ("SETL " + str_comp_key + ":(" + STR map_comp_inputvars[str_comp_key] + ")") scope:same
    }
  }

  # We execute Pre-processing code so that the variables necessary for the arguments can be set
  IF (str_precallcode <> "") {
    EXECUTE (str_precallcode) scope:same result:exval
    # If the preprocessing code exited with an error-code then we should stop this execution.
    IF (exval > 0) { EXIT }
    IF (ecode) { EXIT }
  }

  # We load the variables back into the map_comp_inputvars, since Pre-processing MIGHT have changed them.
  FOR str_comp_key in:(str_comp_inputvarskeys) sep:("~") {
    SETL map_comp_inputvars[str_comp_key]:(eval(str_comp_key))
  }

  # Add any of the required variables to the map_comp_inputvars and str_comp_inputvarskeys if they are available in this scope but not already part of the map!
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_comp_reqvars) as-string
  SETL str_reqvarsexp:(val)
  FOR str_line in:(str_reqvarsexp) sep:("\n") {
    # Variable I want through: copy(str_line, 0, search(str_line, " : ", 0))
    SETL str_reqvar:(copy(str_line, 0, search(str_line, " : ", 0)))
    IF (type(map_comp_inputvars[str_reqvar]) = "undefined") {
      SETL map_comp_inputvars[str_reqvar]:(eval(str_reqvar))
    }
  }

  IF (val_comp_delay < 0.0) { SETL val_comp_delay:(0.0) }
  IF (val_comp_output < -1 OR val_comp_output > 3) { SETL val_comp_output:(0) }
  IF (val_comp_debug < -1 OR val_comp_debug > 3) { SETL val_comp_debug:(0) }
  FC_EXEC_FC (id_comp_start) val_fc_delay:(val_comp_delay) val_fc_output:(val_comp_output) val_fc_debug:(val_comp_debug) val_fc_execdepth:(val_comp_execdepth) val_fc_printtimes:(0) val_fc_highlight:(0) map_fc_inputvars:(map_comp_inputvars) str_fc_inputvarskeys:(str_comp_inputvarskeys) map_fc_outputvars:map_comp_outputvars str_fc_stdout:str_comp_stdout str_fc_debout:str_comp_debout
  
  # Make the returned variables available in this scope. Each line contains the name of one variable
  # Note: Since the Post-processing code is specified from the point of view of the Attribute Profile, and directly executing the Attribute Profile doesn't use the passed output variables references, we don't have to make them here available, because the code shouldn't know about any of them anyway.
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_comp_retvars) as-string
  SETL str_retvarsexp:(val)
  FOR str_line in:(str_retvarsexp) sep:("\n") {
    SETL str_comp_outactualtype:(type(map_comp_outputvars[str_line]))
    IF (str_comp_outactualtype = "string") {
      EXECUTE ("SETL " + str_line + ":(\"" + map_comp_outputvars[str_line] + "\")") scope:same
    } ELSIF (str_comp_outactualtype = "undefined") {
      EXECUTE ("SETL " + str_line + ":(undefined)") scope:same
    } ELSE {
      EXECUTE ("SETL " + str_line + ":(" + STR map_comp_outputvars[str_line] + ")") scope:same
    }
  }

  # Execute the Post-processing code at the end
  IF (str_postcallcode <> "") {
    EXECUTE (str_postcallcode) scope:same
  }

  # Update the "returned values" in the map_comp_outputvars after the Post-processing, since the Post-processing might have changed their values.
  CC "Core" GET_ATTR_VAL objid:(id_functionobj) attrname:(global_str_execap_comp_retvars) as-string
  SETL str_retvarsexp:(val)
  FOR str_line in:(str_retvarsexp) sep:("\n") {
    SETL map_comp_outputvars[str_line]:(eval(str_line))
  }

  IF (id_unloadmodel > -1) {
    SETL temp_ecode:(ecode) # We want to preserve the ecode after discarding the model
    CC "Core" DISCARD_MODEL modelid:(id_unloadmodel)
    SETG ecode:(temp_ecode)
  }
}



#------------------------------------------------------------------------------
PROCEDURE global EXECAP_COMPLEX_CALL integer:id_functionobj
# This procedure allows to execute an External Functionality described through
# a "Complex Functionality" Attribute Profile and provides the result.
# For more control over certain aspects use EXECAP_COMPLEX_CALL_OVERRIDE.
#------------------------------------------------------------------------------
{
  SETL temp_emptymap:(map())
  EXECAP_COMPLEX_CALL_OVERRIDE (id_functionobj) val_skipprecode:(0) val_skippostcode:(0) val_comp_execdepth:(1) id_comp_start:(-1) val_comp_delay:(0.0) val_comp_output:(0) val_comp_debug:(0) map_comp_inputvars:(map()) str_comp_inputvarskeys:("") map_comp_outputvars:temp_emptymap str_comp_stdout:dummy str_comp_debout:dummy
}

##### BEE-UP SPECIFIC END